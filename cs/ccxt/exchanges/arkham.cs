namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class arkham : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "arkham" },
            { "name", "ARKHAM" },
            { "countries", new List<object>() {"US"} },
            { "version", "v1" },
            { "rateLimit", divide(20, 3) },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", false },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPositions", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFees", true },
                { "fetchWithdrawals", true },
                { "sandbox", false },
                { "setLeverage", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "6h", "6h" },
                { "1d", "24h" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/user-attachments/assets/5cefdcfb-2c10-445b-835c-fa21317bf5ac" },
                { "api", new Dictionary<string, object>() {
                    { "v1", "https://arkm.com/api" },
                } },
                { "www", "https://arkm.com/" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://arkm.com/register?ref=ccxt" },
                    { "discount", 0 },
                } },
                { "doc", new List<object>() {"https://arkm.com/limits-api", "https://info.arkm.com/api-platform"} },
                { "fees", "https://arkm.com/fees" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "alerts", 1 },
                            { "announcements", 1 },
                            { "assets", 1 },
                            { "book", 1 },
                            { "candles", 1 },
                            { "chains", 1 },
                            { "contracts", 1 },
                            { "index-price", 1 },
                            { "index-prices", 1 },
                            { "margin-schedules", 1 },
                            { "marketcapchart", 1 },
                            { "marketcaps", 1 },
                            { "pair", 1 },
                            { "pairs", 1 },
                            { "server-time", 1 },
                            { "ticker", 1 },
                            { "tickers", 1 },
                            { "trades", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "user", 7.5 },
                            { "orders", 7.5 },
                            { "orders/by-client-order-id", 7.5 },
                            { "orders/history", 7.5 },
                            { "orders/history/by-client-order-id", 7.5 },
                            { "orders/history_offset", 7.5 },
                            { "orders/{id}", 7.5 },
                            { "trades", 7.5 },
                            { "trades/history", 7.5 },
                            { "trades/time", 7.5 },
                            { "trigger-orders", 7.5 },
                            { "account/airdrops", 7.5 },
                            { "account/balance-updates", 7.5 },
                            { "account/balances", 7.5 },
                            { "account/balances/ll", 7.5 },
                            { "account/balances/history", 7.5 },
                            { "account/balances/commissions", 7.5 },
                            { "account/deposit/addresses", 7.5 },
                            { "account/deposits", 7.5 },
                            { "account/fees", 7.5 },
                            { "account/funding-rate-payments", 7.5 },
                            { "account/leverage", 7.5 },
                            { "account/lsp-assignments", 7.5 },
                            { "account/margin", 7.5 },
                            { "account/margin/all", 7.5 },
                            { "account/notifications", 7.5 },
                            { "account/position-updates", 7.5 },
                            { "account/positions", 7.5 },
                            { "account/realized-pnl", 7.5 },
                            { "account/rebates", 7.5 },
                            { "account/referral-links", 7.5 },
                            { "account/sessions", 7.5 },
                            { "account/settings", 7.5 },
                            { "account/settings/price-alert", 7.5 },
                            { "account/transfers", 7.5 },
                            { "account/unsubscribe", 7.5 },
                            { "account/watchlist", 7.5 },
                            { "account/withdrawal/addresses", 7.5 },
                            { "account/withdrawal/addresses/{id}", 7.5 },
                            { "account/withdrawals", 7.5 },
                            { "subaccounts", 7.5 },
                            { "airdrop", 7.5 },
                            { "airdrop/claim", 7.5 },
                            { "affiliate-dashboard/commission-earned", 7.5 },
                            { "affiliate-dashboard/min-arkm-last-30d", 7.5 },
                            { "affiliate-dashboard/points", 7.5 },
                            { "affiliate-dashboard/points-season-1", 7.5 },
                            { "affiliate-dashboard/points-season-2", 7.5 },
                            { "affiliate-dashboard/realized-pnl", 7.5 },
                            { "affiliate-dashboard/rebate-balance", 7.5 },
                            { "affiliate-dashboard/referral-count", 7.5 },
                            { "affiliate-dashboard/referrals-season-1", 7.5 },
                            { "affiliate-dashboard/referrals-season-2", 7.5 },
                            { "affiliate-dashboard/trading-volume-stats", 7.5 },
                            { "affiliate-dashboard/volume-season-1", 7.5 },
                            { "affiliate-dashboard/volume-season-2", 7.5 },
                            { "affiliate-dashboard/api-key", 7.5 },
                            { "competitions/opt-in-status", 7.5 },
                            { "rewards/info", 7.5 },
                            { "rewards/vouchers", 7.5 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "orders/new", 7.5 },
                            { "trigger-orders/new", 7.5 },
                            { "orders/cancel", 7.5 },
                            { "trigger-orders/cancel", 7.5 },
                            { "orders/cancel/all", 7.5 },
                            { "trigger-orders/cancel/all", 7.5 },
                            { "orders/new/simple", 7.5 },
                            { "account/deposit/addresses/new", 7.5 },
                            { "account/leverage", 7.5 },
                            { "account/notifications/read", 7.5 },
                            { "account/referral-links", 7.5 },
                            { "account/sessions/delete", 7.5 },
                            { "account/sessions/terminate-all", 7.5 },
                            { "account/settings/update", 7.5 },
                            { "account/watchlist/add", 7.5 },
                            { "account/watchlist/remove", 7.5 },
                            { "account/withdraw", 7.5 },
                            { "account/withdrawal/addresses/confirm", 7.5 },
                            { "subaccounts", 7.5 },
                            { "subaccounts/transfer", 7.5 },
                            { "subaccounts/perp-transfer", 7.5 },
                            { "subaccounts/update-settings", 7.5 },
                            { "airdrop", 7.5 },
                            { "api-key/create", 7.5 },
                            { "authenticate", 7.5 },
                            { "competitions/opt-in", 7.5 },
                            { "rewards/vouchers/claim", 7.5 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "account/referral-links/{id}/slug", 7.5 },
                            { "account/settings/price-alert", 7.5 },
                            { "account/withdrawal/addresses/{id}", 7.5 },
                            { "subaccounts", 7.5 },
                            { "api-key/update/{id}", 7.5 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "account/settings/price-alert", 7.5 },
                            { "account/withdrawal/addresses/{id}", 7.5 },
                            { "subaccounts/{subaccountId}", 7.5 },
                            { "api-key/{id}", 7.5 },
                        } },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "ETH" },
                    { "ERC20", "ETH" },
                    { "BTC", "BTC" },
                    { "SOL", "SOL" },
                    { "TON", "TON" },
                    { "DOGE", "DOGE" },
                    { "SUI", "SUI" },
                    { "XRP", "XRP" },
                    { "OP", "OP" },
                    { "AVAXC", "AVAX" },
                    { "ARBONE", "ARB" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "ERC20", "ERC20" },
                } },
                { "requestExpiration", 5000 },
                { "timeframeDurations", new Dictionary<string, object>() {
                    { "1m", 60000000 },
                    { "5m", 300000000 },
                    { "15m", 900000000 },
                    { "30m", 1800000000 },
                    { "1h", 3600000000 },
                    { "6h", 21600000000 },
                    { "1d", 86400000000 },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", false },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerPriceType", new Dictionary<string, object>() {
                            { "mark", true },
                            { "index", true },
                            { "last", true },
                        } },
                        { "triggerDirection", true },
                        { "stopLossPrice", true },
                        { "takeProfitPrice", true },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "selfTradePrevention", false },
                        { "trailing", false },
                        { "iceberg", false },
                        { "leverage", false },
                        { "marketBuyByCost", false },
                        { "marketBuyRequiresPrice", false },
                    } },
                    { "createOrders", null },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", null },
                        { "untilDays", 1 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", true },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 100 },
                        { "daysBack", null },
                        { "daysBackCanceled", null },
                        { "untilDays", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 365 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "10000", typeof(OperationFailed) },
                    { "10001", typeof(BadRequest) },
                    { "10002", typeof(AuthenticationError) },
                    { "10003", typeof(BadSymbol) },
                    { "10004", typeof(ArgumentsRequired) },
                    { "10005", typeof(RateLimitExceeded) },
                    { "10006", typeof(PermissionDenied) },
                    { "10007", typeof(PermissionDenied) },
                    { "10008", typeof(RateLimitExceeded) },
                    { "10009", typeof(PermissionDenied) },
                    { "10010", typeof(PermissionDenied) },
                    { "10011", typeof(AuthenticationError) },
                    { "10012", typeof(PermissionDenied) },
                    { "10013", typeof(PermissionDenied) },
                    { "10014", typeof(AuthenticationError) },
                    { "10015", typeof(PermissionDenied) },
                    { "10016", typeof(PermissionDenied) },
                    { "10017", typeof(PermissionDenied) },
                    { "10018", typeof(AuthenticationError) },
                    { "10019", typeof(AuthenticationError) },
                    { "10020", typeof(PermissionDenied) },
                    { "10021", typeof(PermissionDenied) },
                    { "10022", typeof(ExchangeError) },
                    { "10023", typeof(BadRequest) },
                    { "10024", typeof(ExchangeError) },
                    { "10025", typeof(BadRequest) },
                    { "20001", typeof(BadRequest) },
                    { "20002", typeof(ArgumentsRequired) },
                    { "20003", typeof(BadRequest) },
                    { "20004", typeof(ArgumentsRequired) },
                    { "20005", typeof(BadRequest) },
                    { "30001", typeof(InvalidOrder) },
                    { "30002", typeof(InvalidOrder) },
                    { "30003", typeof(InvalidOrder) },
                    { "30004", typeof(InvalidOrder) },
                    { "30005", typeof(InvalidOrder) },
                    { "30006", typeof(InvalidOrder) },
                    { "30007", typeof(BadSymbol) },
                    { "30008", typeof(OperationRejected) },
                    { "30009", typeof(OperationRejected) },
                    { "30010", typeof(InsufficientFunds) },
                    { "30011", typeof(BadSymbol) },
                    { "30012", typeof(OperationRejected) },
                    { "30013", typeof(OperationRejected) },
                    { "30014", typeof(InvalidOrder) },
                    { "30015", typeof(OrderNotFound) },
                    { "30016", typeof(InvalidOrder) },
                    { "30017", typeof(InvalidOrder) },
                    { "30018", typeof(InvalidOrder) },
                    { "30019", typeof(OperationRejected) },
                    { "30020", typeof(InvalidOrder) },
                    { "30021", typeof(InvalidOrder) },
                    { "30022", typeof(InvalidOrder) },
                    { "30023", typeof(InvalidOrder) },
                    { "30024", typeof(InvalidOrder) },
                    { "30025", typeof(BadRequest) },
                    { "30026", typeof(PermissionDenied) },
                    { "30027", typeof(PermissionDenied) },
                    { "30028", typeof(OrderNotFound) },
                    { "40001", typeof(OperationRejected) },
                    { "40002", typeof(BadRequest) },
                    { "40003", typeof(InvalidAddress) },
                    { "40004", typeof(OperationRejected) },
                    { "40005", typeof(BadRequest) },
                    { "40006", typeof(PermissionDenied) },
                    { "40007", typeof(OperationRejected) },
                    { "40008", typeof(OperationRejected) },
                    { "40009", typeof(OperationRejected) },
                    { "40010", typeof(BadRequest) },
                    { "40011", typeof(OperationRejected) },
                    { "40012", typeof(BadRequest) },
                    { "40013", typeof(BadRequest) },
                    { "90001", typeof(BadRequest) },
                    { "90002", typeof(BadRequest) },
                    { "90003", typeof(OperationRejected) },
                    { "90004", typeof(BadRequest) },
                    { "90005", typeof(BadRequest) },
                    { "90006", typeof(RateLimitExceeded) },
                    { "90007", typeof(AuthenticationError) },
                    { "90008", typeof(RateLimitExceeded) },
                    { "90009", typeof(PermissionDenied) },
                    { "90010", typeof(BadRequest) },
                    { "90011", typeof(RateLimitExceeded) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "less than min withdrawal ", typeof(OperationRejected) },
                } },
            } },
        });
    }

    /**
     * @method
     * @name arkham#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://arkm.com/docs#get/public/assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetAssets(parameters);
        //
        //    [
        //        {
        //            "symbol": "USDT",
        //            "name": "Tether",
        //            "imageUrl": "https://static.arkhamintelligence.com/tokens/tether.png",
        //            "stablecoin": true,
        //            "featuredPair": "BTC_USDT",
        //            "chains": [
        //                {
        //                    "symbol": "ETH",
        //                    "assetSymbol": "ETH",
        //                    "name": "Ethereum",
        //                    "type": "1",
        //                    "confirmations": "6",
        //                    "blockTime": "12000000"
        //                }
        //            ],
        //            "status": "listed",
        //            "minDeposit": "5",
        //            "minWithdrawal": "5",
        //            "withdrawalFee": "2"
        //        },
        //        ...
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "symbol");
            object code = this.safeCurrencyCode(id);
            object networks = new Dictionary<string, object>() {};
            object chains = this.safeList(currency, "chains", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "symbol");
                object network = this.networkIdToCode(networkId);
                ((IDictionary<string,object>)networks)[(string)network] = new Dictionary<string, object>() {
                    { "info", chain },
                    { "id", networkId },
                    { "network", network },
                    { "title", this.safeString(chain, "name") },
                    { "active", null },
                    { "deposit", null },
                    { "withdraw", null },
                    { "fee", null },
                    { "precision", null },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                };
            }
            ((IDictionary<string,object>)result)[(string)code] = this.safeCurrencyStructure(new Dictionary<string, object>() {
                { "info", currency },
                { "id", id },
                { "code", code },
                { "name", this.safeString(currency, "name") },
                { "active", isEqual(this.safeString(currency, "status"), "listed") },
                { "deposit", null },
                { "withdraw", null },
                { "fee", this.safeNumber(currency, "withdrawalFee") },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minWithdrawal") },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minDeposit") },
                        { "max", null },
                    } },
                } },
                { "type", "crypto" },
                { "networks", networks },
            });
        }
        return result;
    }

    /**
     * @method
     * @name arkham#fetchMarkets
     * @see https://arkm.com/docs#get/public/pairs
     * @description retrieves data on all markets for arkm
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetPairs(parameters);
        //
        //    [
        //        {
        //            "symbol": "BTC_USDT",
        //            "baseSymbol": "BTC",
        //            "baseImageUrl": "https://static.arkhamintelligence.com/tokens/bitcoin.png",
        //            "baseIsStablecoin": false,
        //            "baseName": "Bitcoin",
        //            "quoteSymbol": "USDT",
        //            "quoteImageUrl": "https://static.arkhamintelligence.com/tokens/tether.png",
        //            "quoteIsStablecoin": true,
        //            "quoteName": "Tether",
        //            "minTickPrice": "0.01",
        //            "minLotSize": "0.00001",
        //            "minSize": "0.00001",
        //            "maxSize": "9000",
        //            "minPrice": "0.01",
        //            "maxPrice": "1000000",
        //            "minNotional": "5",
        //            "maxPriceScalarUp": "1.8",
        //            "maxPriceScalarDown": "0.2",
        //            "pairType": "spot", // atm, always 'spot' value
        //            "maxLeverage": "0",
        //            "status": "listed"
        //        },
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "baseSymbol": "BTC.P",
        //            "baseImageUrl": "https://static.arkhamintelligence.com/tokens/bitcoin.png",
        //            "baseIsStablecoin": false,
        //            "baseName": "Bitcoin Perpetual",
        //            "quoteSymbol": "USDT",
        //            "quoteImageUrl": "https://static.arkhamintelligence.com/tokens/tether.png",
        //            "quoteIsStablecoin": true,
        //            "quoteName": "Tether",
        //            "minTickPrice": "0.01",
        //            "minLotSize": "0.00001",
        //            "minSize": "0.00001",
        //            "maxSize": "9000",
        //            "minPrice": "0.01",
        //            "maxPrice": "1000000",
        //            "minNotional": "5",
        //            "maxPriceScalarUp": "1.5",
        //            "maxPriceScalarDown": "0.5",
        //            "pairType": "perpetual",
        //            "marginSchedule": "C",
        //            "maxLeverage": "25",
        //            "status": "listed"
        //        },
        //        ...
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "baseSymbol");
            object quoteId = this.safeString(market, "quoteSymbol");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object marketType = null;
            object symbol = null;
            object pairType = this.safeString(market, "pairType");
            object isSpot = isEqual(pairType, "spot");
            object isPerpetual = isEqual(pairType, "perpetual");
            object settle = null;
            object settleId = null;
            if (isTrue(isSpot))
            {
                marketType = "spot";
                symbol = add(add(bs, "/"), quote);
            } else if (isTrue(isPerpetual))
            {
                marketType = "swap";
                bs = ((string)bs).Replace((string)".P", (string)"");
                settle = quote;
                settleId = quoteId;
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", marketType },
                { "spot", isSpot },
                { "margin", null },
                { "swap", isPerpetual },
                { "future", false },
                { "option", false },
                { "active", isEqual(this.safeString(market, "status"), "listed") },
                { "contract", isPerpetual },
                { "linear", ((bool) isTrue(isPerpetual)) ? true : null },
                { "inverse", ((bool) isTrue(isPerpetual)) ? false : null },
                { "contractSize", ((bool) isTrue(isSpot)) ? null : 1 },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "price", this.safeNumber(market, "minTickPrice") },
                    { "amount", this.safeNumber(market, "minLotSize") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minSize") },
                        { "max", this.safeNumber(market, "maxSize") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minPrice") },
                        { "max", this.safeNumber(market, "maxPrice") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minNotional") },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    /**
     * @method
     * @name arkham#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://arkm.com/docs#get/public/server-time
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetServerTime(parameters);
        //
        //    {
        //        "serverTime": "1753465832770820"
        //    }
        //
        return this.safeIntegerProduct(response, "serverTime", 0.001);
    }

    /**
     * @method
     * @name arkham#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://arkm.com/docs#get/public/book
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the number of order book entries to return, max 50
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetBook(this.extend(request, parameters));
        //
        //    {
        //        "symbol": "BTC_USDT",
        //        "group": "0.01",
        //        "asks": [
        //            {
        //                "price": "122900.43",
        //                "size": "0.0243"
        //            },
        //            {
        //                "price": "121885.53",
        //                "size": "0.00116"
        //            },
        //            ...
        //        ],
        //        "bids": [
        //            {
        //                "price": "20400",
        //                "size": "0.00316"
        //            },
        //            {
        //                "price": "30000",
        //                "size": "0.00116"
        //            },
        //            ...
        //        ],
        //        "lastTime": "1753419275604353"
        //    }
        //
        object timestamp = this.safeIntegerProduct(response, "lastTime", 0.001);
        object marketId = this.safeString(response, "symbol");
        return this.parseOrderBook(response, this.safeSymbol(marketId, market), timestamp, "bids", "asks", "price", "size");
    }

    /**
     * @method
     * @name arkham#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://arkm.com/docs#get/public/candles
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        object maxLimit = 365;
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, maxLimit);
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "duration", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object durationMs = multiply(this.parseTimeframe(timeframe), 1000);
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"until"});
        object selectedLimit = ((bool) isTrue((!isEqual(limit, null)))) ? mathMin(limit, maxLimit) : maxLimit;
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start"] = since;
            ((IDictionary<string,object>)request)["end"] = this.sum(since, multiply(selectedLimit, durationMs));
        } else
        {
            object now = this.milliseconds();
            ((IDictionary<string,object>)request)["end"] = ((bool) isTrue((!isEqual(until, null)))) ? until : now;
            ((IDictionary<string,object>)request)["start"] = subtract(getValue(request, "end"), multiply(selectedLimit, durationMs));
        }
        // exchange needs microseconds
        ((IDictionary<string,object>)request)["start"] = multiply(getValue(request, "start"), 1000);
        ((IDictionary<string,object>)request)["end"] = multiply(getValue(request, "end"), 1000);
        object response = await this.v1PublicGetCandles(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "time": "1753464720000000",
        //            "duration": "60000000",
        //            "open": "116051.35",
        //            "high": "116060.27",
        //            "low": "116051.35",
        //            "close": "116060.27",
        //            "volume": "0.0257",
        //            "quoteVolume": "2982.6724054"
        //        },
        //        ...
        //    ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "time": "1753464720000000",
        //            "duration": "60000000",
        //            "open": "116051.35",
        //            "high": "116060.27",
        //            "low": "116051.35",
        //            "close": "116060.27",
        //            "volume": "0.0257",
        //            "quoteVolume": "2982.6724054"
        //        }
        //
        return new List<object> {this.safeIntegerProduct(ohlcv, "time", 0.001), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetTickers(parameters);
        //
        //    [
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "baseSymbol": "BTC.P",
        //            "quoteSymbol": "USDT",
        //            "indexCurrency": "USDT",
        //            "price": "118806.89",
        //            "price24hAgo": "118212.29",
        //            "high24h": "119468.05",
        //            "low24h": "117104.44",
        //            "volume24h": "180.99438",
        //            "quoteVolume24h": "21430157.5928827",
        //            "markPrice": "118814.71",
        //            "indexPrice": "118804.222610343",
        //            "fundingRate": "0.000007",
        //            "nextFundingRate": "0.000006",
        //            "nextFundingTime": "1753390800000000",
        //            "productType": "perpetual",
        //            "openInterest": "2.55847",
        //            "usdVolume24h": "21430157.5928827",
        //            "openInterestUSD": "303963.8638583"
        //        },
        //        ...
        //
        return this.parseTickers(response, symbols);
    }

    /**
     * @method
     * @name arkham#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetTicker(this.extend(request, parameters));
        //
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "baseSymbol": "BTC.P",
        //            "quoteSymbol": "USDT",
        //            "indexCurrency": "USDT",
        //            "price": "118806.89",
        //            "price24hAgo": "118212.29",
        //            "high24h": "119468.05",
        //            "low24h": "117104.44",
        //            "volume24h": "180.99438",
        //            "quoteVolume24h": "21430157.5928827",
        //            "markPrice": "118814.71",
        //            "indexPrice": "118804.222610343",
        //            "fundingRate": "0.000007",
        //            "nextFundingRate": "0.000006",
        //            "nextFundingTime": "1753390800000000",
        //            "productType": "perpetual",
        //            "openInterest": "2.55847",
        //            "usdVolume24h": "21430157.5928827",
        //            "openInterestUSD": "303963.8638583"
        //        }
        //
        return this.parseTicker(response, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        return this.safeTicker(new Dictionary<string, object>() {
            { "info", ticker },
            { "symbol", this.safeSymbol(marketId, market) },
            { "high", this.safeNumber(ticker, "high24h") },
            { "low", this.safeNumber(ticker, "low24h") },
            { "bid", this.safeNumber(ticker, "bid") },
            { "last", this.safeNumber(ticker, "price") },
            { "open", this.safeNumber(ticker, "price24hAgo") },
            { "change", this.safeNumber(ticker, "priceChange") },
            { "percentage", this.safeNumber(ticker, "priceChangePercent") },
            { "baseVolume", this.safeNumber(ticker, "volume24h") },
            { "quoteVolume", this.safeNumber(ticker, "usdVolume24h") },
            { "markPrice", this.safeNumber(ticker, "markPrice") },
            { "indexPrice", this.safeNumber(ticker, "indexPrice") },
            { "vwap", null },
            { "average", null },
            { "previousClose", null },
            { "askVolume", null },
            { "bidVolume", null },
        });
    }

    /**
     * @method
     * @name arkham#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://arkm.com/docs#get/public/trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.loc] crypto location, default: us
     * @param {string} [params.method] method, default: marketPublicGetV1beta3CryptoLocTrades
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetTrades(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "revisionId": "1130514101",
        //            "size": "0.01668",
        //            "price": "116309.57",
        //            "takerSide": "sell",
        //            "time": "1753439710374047"
        //        },
        //        ...
        //    ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades
        //
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "revisionId": "1130514101",
        //            "size": "0.01668",
        //            "price": "116309.57",
        //            "takerSide": "sell",
        //            "time": "1753439710374047"
        //        }
        //
        // fetchMyTrades
        //
        //        {
        //            "symbol": "SOL_USDT",
        //            "revisionId": "891839406",
        //            "size": "0.042",
        //            "price": "185.06",
        //            "takerSide": "sell",
        //            "time": "1753773952039342",
        //            "orderId": "3717304929194",
        //            "userSide": "sell",
        //            "quoteFee": "0.00777252",
        //            "arkmFee": "0",
        //            "clientOrderId": ""
        //        }
        //
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeIntegerProduct(trade, "time", 0.001);
        object quoteFee = this.safeNumber(trade, "quoteFee");
        object arkmFee = this.safeNumber(trade, "arkmFee");
        object fee = null;
        if (isTrue(!isEqual(quoteFee, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", quoteFee },
                { "currency", getValue(market, "quote") },
            };
        } else if (isTrue(!isEqual(arkmFee, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", arkmFee },
                { "currency", "ARKM" },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", this.safeString(trade, "revisionId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "side", this.safeString2(trade, "userSide", "takerSide") },
            { "takerOrMaker", null },
            { "price", this.safeString(trade, "price") },
            { "amount", this.safeString(trade, "size") },
            { "cost", null },
            { "fee", fee },
            { "order", this.safeString(trade, "orderId") },
        }, market);
    }

    /**
     * @method
     * @name arkmm#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://arkm.com/docs#get/orders/by-client-order-id
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.clientOrderId] a unique id for the order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "id", parseInt(id) },
        };
        object response = await this.v1PrivateGetOrdersId(this.extend(request, parameters));
        //
        //    {
        //        "orderId": "3690478767430",
        //        "userId": "2959123",
        //        "subaccountId": "0",
        //        "symbol": "SOL_USDT",
        //        "time": "1753696843913970",
        //        "side": "sell",
        //        "type": "limitGtc",
        //        "size": "0.066",
        //        "price": "293.2",
        //        "postOnly": false,
        //        "reduceOnly": false,
        //        "executedSize": "0",
        //        "status": "booked",
        //        "avgPrice": "0",
        //        "executedNotional": "0",
        //        "creditFeePaid": "0",
        //        "marginBonusFeePaid": "0",
        //        "quoteFeePaid": "0",
        //        "arkmFeePaid": "0",
        //        "revisionId": "887956326",
        //        "lastTime": "1753696843914830",
        //        "clientOrderId": "",
        //        "lastSize": "0",
        //        "lastPrice": "0",
        //        "lastCreditFee": "0",
        //        "lastMarginBonusFee": "0",
        //        "lastQuoteFee": "0",
        //        "lastArkmFee": "0"
        //    }
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name arkham#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://arkm.com/docs#get/orders/history
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit; // note, API does not work for this param
        }
        object response = await this.v1PrivateGetOrdersHistory(this.extend(request, parameters));
        //
        //     [
        //        {
        //            "orderId": "3690478767430",
        //            "userId": "2959123",
        //            "subaccountId": "0",
        //            "symbol": "SOL_USDT",
        //            "time": "1753696843913970",
        //            "side": "sell",
        //            "type": "limitGtc",
        //            "size": "0.066",
        //            "price": "293.2",
        //            "postOnly": false,
        //            "reduceOnly": false,
        //            "executedSize": "0",
        //            "status": "closed",
        //            "avgPrice": "0",
        //            "executedNotional": "0",
        //            "creditFeePaid": "0",
        //            "marginBonusFeePaid": "0",
        //            "quoteFeePaid": "0",
        //            "arkmFeePaid": "0",
        //            "revisionId": "888084076",
        //            "lastTime": "1753701350088305",
        //            "clientOrderId": "",
        //            "lastSize": "0",
        //            "lastPrice": "0",
        //            "lastCreditFee": "0",
        //            "lastMarginBonusFee": "0",
        //            "lastQuoteFee": "0",
        //            "lastArkmFee": "0"
        //        }
        //    ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name arkham#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://arkm.com/docs#get/orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object isTriggerOrder = this.safeBool(parameters, "trigger");
        parameters = this.omit(parameters, "trigger");
        object response = null;
        if (isTrue(isTriggerOrder))
        {
            response = await this.v1PrivateGetTriggerOrders(this.extend(new Dictionary<string, object>() {}, parameters));
        } else
        {
            response = await this.v1PrivateGetOrders(this.extend(new Dictionary<string, object>() {}, parameters));
        }
        return this.parseOrders(response, market, since, limit);
    }

    /**
     * @method
     * @name arkham#cancelOrder
     * @description cancels an open order
     * @see https://arkm.com/docs#post/orders/cancel
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object isTriggerOrder = this.safeBool(parameters, "trigger");
        parameters = this.omit(parameters, "trigger");
        object response = null;
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeInteger(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            parameters = this.omit(parameters, "clientOrderId");
            ((IDictionary<string,object>)request)["clientOrderId"] = clientOrderId;
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                ((IDictionary<string,object>)request)["triggerOrderId"] = parseInt(id);
            } else
            {
                ((IDictionary<string,object>)request)["orderId"] = parseInt(id);
            }
        }
        if (isTrue(isTriggerOrder))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument for trigger orders")) ;
            }
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
            response = await this.v1PrivatePostTriggerOrdersCancel(this.extend(request, parameters));
        } else
        {
            response = await this.v1PrivatePostOrdersCancel(this.extend(request, parameters));
        }
        //
        // {"orderId":3691703758327}
        //
        return this.parseOrder(response);
    }

    /**
     * @method
     * @name arkham#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://arkm.com/docs#post/orders/cancel/all
     * @param {string} symbol cancel alls open orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbol, null)))
        {
            throw new BadRequest ((string)add(this.id, " cancelAllOrders() does not support a symbol argument, use cancelOrder() or fetchOpenOrders() instead")) ;
        }
        object isTriggerOrder = this.safeBool(parameters, "trigger");
        parameters = this.omit(parameters, "trigger");
        object response = null;
        if (isTrue(isTriggerOrder))
        {
            response = await this.v1PrivatePostTriggerOrdersCancelAll(parameters);
        } else
        {
            response = await this.v1PrivatePostOrdersCancelAll(parameters);
        }
        //
        // []  returns an empty array, even when successfully cancels orders
        //
        return this.parseOrders(response, null);
    }

    /**
     * @method
     * @name arkham#createOrder
     * @description create a trade order on the exchange
     * @see https://arkm.com/docs#post/orders/new
     * @param {string} symbol unified CCXT market symbol
     * @param {string} type "limit" or "market"
     * @param {string} side "buy" or "sell"
     * @param {float} amount the amount of currency to trade
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
     * @param {float} [params.triggerPrice] price for a trigger (conditional) order
     * @param {float} [params.stopLossPrice] price for a stoploss order
     * @param {float} [params.takeProfitPrice] price for a takeprofit order
     * @param {string} [params.triggerDirection] the direction for trigger orders, 'ascending' or 'descending'
     * @param {string} [params.triggerPriceType] mark, index or last
     * @param {bool} [params.postOnly] true or false whether the order is post-only
     * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
     * @returns [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object isTriggerOrder = !isEqual(this.safeNumberN(parameters, new List<object>() {"triggerPrice", "stopLossPrice", "takeProfitPrice"}), null);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(isTriggerOrder))
        {
            response = await this.v1PrivatePostTriggerOrdersNew(request);
        } else
        {
            response = await this.v1PrivatePostOrdersNew(request);
        }
        return this.parseOrder(response, market);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        symbol = getValue(market, "symbol");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", side },
            { "size", this.amountToPrecision(symbol, amount) },
        };
        object isBuy = (isEqual(side, "buy"));
        object stopLossPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeNumber(parameters, "takeProfitPrice");
        object triggerPriceAny = this.safeStringN(parameters, new List<object>() {"triggerPrice", "stopLossPrice", "takeProfitPrice"});
        if (isTrue(!isEqual(triggerPriceAny, null)))
        {
            ((IDictionary<string,object>)request)["triggerPrice"] = this.priceToPrecision(symbol, triggerPriceAny);
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((IDictionary<string,object>)request)["triggerType"] = ((bool) isTrue(isBuy)) ? "stopLoss" : "takeProfit";
            } else if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((IDictionary<string,object>)request)["triggerType"] = ((bool) isTrue(isBuy)) ? "takeProfit" : "stopLoss";
            } else
            {
                object triggerDirection = this.safeString(parameters, "triggerDirection");
                if (isTrue(isEqual(triggerDirection, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a triggerDirection parameter when triggerPrice is specified, must be \"ascending\" or \"descending\"")) ;
                }
                if (isTrue(!isEqual(triggerDirection, null)))
                {
                    if (isTrue(isEqual(triggerDirection, "ascending")))
                    {
                        ((IDictionary<string,object>)request)["triggerType"] = ((bool) isTrue(isBuy)) ? "stopLoss" : "takeProfit";
                    } else if (isTrue(isEqual(triggerDirection, "descending")))
                    {
                        ((IDictionary<string,object>)request)["triggerType"] = ((bool) isTrue(isBuy)) ? "takeProfit" : "stopLoss";
                    }
                }
            }
            // mandatory triggerPriceType
            if (isTrue(isEqual(this.safeString(parameters, "triggerPriceType"), null)))
            {
                ((IDictionary<string,object>)request)["triggerPriceType"] = "last"; // default
            }
        }
        object isMarketOrder = (isEqual(type, "market"));
        object isLimitOrder = (isEqual(type, "limit"));
        object isLimitExchangeSpecific = this.inArray(type, new List<object>() {"limitGtc", "limitIoc", "limitFok"});
        object postOnly = this.isPostOnly(isMarketOrder, false, parameters);
        object timeInForce = this.safeString(parameters, "timeInForce");
        parameters = this.omit(parameters, new List<object>() {"postOnly", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "triggerDirection"});
        if (isTrue(postOnly))
        {
            ((IDictionary<string,object>)request)["postOnly"] = true;
        }
        if (isTrue(isTrue(isLimitOrder) || isTrue(isLimitExchangeSpecific)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            //
            if (isTrue(isEqual(timeInForce, "IOC")))
            {
                ((IDictionary<string,object>)request)["type"] = "limitIoc";
            } else if (isTrue(isEqual(timeInForce, "FOK")))
            {
                ((IDictionary<string,object>)request)["type"] = "limitFok";
            } else
            {
                ((IDictionary<string,object>)request)["type"] = "limitGtc";
            }
        } else if (isTrue(isMarketOrder))
        {
            ((IDictionary<string,object>)request)["type"] = "market";
        }
        // we don't need to manually handle `reduceOnly`, `clientOrderId`, `triggerPriceType` here as exchange-specific keyname & values matches
        return this.extend(request, parameters);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //    {
        //        "orderId": "3694872060678",
        //        "clientOrderId": "test123",
        //        "symbol": "SOL_USDT",
        //        "subaccountId": "0",
        //        "side": "buy",
        //        "type": "limitGtc",
        //        "size": "0.05",
        //        "price": "170",
        //        "time": "1753710501474043"
        //    }
        //
        // fetchOrder, fetchOpenOrders, fetchClosedOrders
        //
        //    {
        //        "orderId": "3690478767430",
        //        "userId": "2959123",
        //        "subaccountId": "0",
        //        "symbol": "SOL_USDT",
        //        "time": "1753696843913970",
        //        "side": "sell",
        //        "type": "limitGtc",
        //        "size": "0.066",
        //        "price": "293.2",
        //        "postOnly": false,
        //        "reduceOnly": false,
        //        "executedSize": "0",
        //        "status": "booked",
        //        "avgPrice": "0",
        //        "executedNotional": "0",
        //        "creditFeePaid": "0",
        //        "marginBonusFeePaid": "0",
        //        "quoteFeePaid": "0",
        //        "arkmFeePaid": "0",
        //        "revisionId": "887956326",
        //        "lastTime": "1753696843914830",
        //        "clientOrderId": "",
        //        "lastSize": "0",
        //        "lastPrice": "0",
        //        "lastCreditFee": "0",
        //        "lastMarginBonusFee": "0",
        //        "lastQuoteFee": "0",
        //        "lastArkmFee": "0"
        //    }
        //
        // trigger-orders: createOrder
        //
        //    {
        //        "triggerOrderId": "3716436645573",
        //        "symbol": "SOL_USDT_PERP",
        //        "side": "buy",
        //        "type": "limitGtc",
        //        "size": "0.05",
        //        "price": "150"
        //    }
        //
        // trigger-orders: fetchOpenOrders
        //
        //    {
        //            "subaccountId": "0",
        //            "symbol": "SOL_USDT",
        //            "side": "sell",
        //            "type": "market",
        //            "size": "0.045",
        //            "price": "99.9",
        //            "postOnly": false,
        //            "reduceOnly": false,
        //            "time": "1753768103780063",
        //            "triggerOrderId": "3715847222127",
        //            "triggerType": "stopLoss",
        //            "triggerPriceType": "last",
        //            "triggerPrice": "111",
        //            "clientOrderId": "",
        //            "status": "staged"
        //    }
        //
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object isPostOnly = this.safeBool(order, "postOnly");
        object typeRaw = this.safeString(order, "type");
        object orderType = ((bool) isTrue(isPostOnly)) ? "limit" : this.parseOrderType(typeRaw);
        object timeInForce = ((bool) isTrue(isPostOnly)) ? "PO" : this.parseTimeInForce(typeRaw);
        object quoteFeePaid = this.safeString(order, "quoteFeePaid");
        object arkmFeePaid = this.safeString(order, "arkmFeePaid");
        object fees = new List<object>() {};
        if (isTrue(!isEqual(quoteFeePaid, null)))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", quoteFeePaid },
                { "currency", this.safeString(market, "quote") },
            });
        }
        if (isTrue(!isEqual(arkmFeePaid, null)))
        {
            ((IList<object>)fees).Add(new Dictionary<string, object>() {
                { "cost", arkmFeePaid },
                { "currency", "ARKM" },
            });
        }
        object timestamp = this.safeIntegerProduct(order, "time", 0.001);
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString2(order, "orderId", "triggerOrderId") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimeStamp", null },
            { "lastUpdateTimestamp", this.safeIntegerProduct(order, "lastTime", 0.001) },
            { "status", this.parseOrderStatus(this.safeString(order, "status")) },
            { "symbol", getValue(market, "symbol") },
            { "type", orderType },
            { "timeInForce", timeInForce },
            { "postOnly", null },
            { "side", this.safeString(order, "side") },
            { "price", this.safeNumber(order, "price") },
            { "triggerPrice", null },
            { "cost", this.safeNumber(order, "executedNotional") },
            { "average", this.safeNumberOmitZero(order, "avgPrice") },
            { "amount", this.safeNumber(order, "size") },
            { "filled", this.safeNumber(order, "") },
            { "remaining", null },
            { "trades", null },
            { "fees", fees },
            { "reduceOnly", this.safeBool(order, "reduceOnly") },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "limitGtc", "limit" },
            { "limitIoc", "limit" },
            { "limitFok", "limit" },
            { "market", "market" },
        };
        return this.safeStringUpper(types, type, type);
    }

    public virtual object parseTimeInForce(object type)
    {
        object types = new Dictionary<string, object>() {
            { "limitGtc", "GTC" },
            { "limitIoc", "IOC" },
            { "limitFok", "FOK" },
            { "market", "IOC" },
        };
        return this.safeStringUpper(types, type, type);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "new", "pending" },
            { "staged", "open" },
            { "booked", "open" },
            { "taker", "closed" },
            { "maker", "closed" },
            { "cancelled", "canceled" },
            { "closed", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name arkham#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://arkm.com/docs#get/trades/time
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch trades for
     * @param {string} [params.page_token] page_token - used for paging
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        // exchange needs to obtain some `from & to` values, otherwise it does not return any result
        object defaultRange = multiply(multiply(multiply(24, 60), 60), 1000); // default to last 24 hours
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["from"] = multiply(since, 1000); // convert ms to microseconds
        } else
        {
            ((IDictionary<string,object>)request)["from"] = multiply((subtract(this.milliseconds(), defaultRange)), 1000); // default to last 24 hours
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            parameters = this.omit(parameters, "until");
            ((IDictionary<string,object>)request)["to"] = multiply(until, 1000); // convert ms to microseconds
        } else
        {
            ((IDictionary<string,object>)request)["to"] = this.sum(getValue(request, "from"), multiply(defaultRange, 1000));
        }
        var requestparametersVariable = this.handleUntilOption("until", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.v1PrivateGetTradesTime(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "symbol": "SOL_USDT",
        //            "revisionId": "891839406",
        //            "size": "0.042",
        //            "price": "185.06",
        //            "takerSide": "sell",
        //            "time": "1753773952039342",
        //            "orderId": "3717304929194",
        //            "userSide": "sell",
        //            "quoteFee": "0.00777252",
        //            "arkmFee": "0",
        //            "clientOrderId": ""
        //        },
        //        ...
        //
        return this.parseTrades(response, null, since, limit);
    }

    /**
     * @method
     * @name arkham#fetchAccounts
     * @description fetch all the accounts associated with a profile
     * @see https://arkm.com/docs#get/user
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object accountId = null;
        var accountIdparametersVariable = this.handleOptionAndParams(parameters, "fetchAccounts", "accountId");
        accountId = ((IList<object>)accountIdparametersVariable)[0];
        parameters = ((IList<object>)accountIdparametersVariable)[1];
        if (isTrue(!isEqual(accountId, null)))
        {
            ((IDictionary<string,object>)request)["subAccountId"] = accountId;
        }
        object response = await this.v1PrivateGetUser(this.extend(request, parameters));
        //
        //    {
        //        "id": "2959123",
        //        "email": "xyz@gmail.com",
        //        "username": "t.123",
        //        "requireMFA": true,
        //        "kycVerifiedAt": "1753434515850673",
        //        "pmm": false,
        //        "dmm": false,
        //        "becameVipAt": "0",
        //        "subaccounts": [
        //            {
        //                "id": "0",
        //                "name": "Primary",
        //                "pinned": true,
        //                "isLsp": false,
        //                "futuresEnabled": true,
        //                "payFeesInArkm": false,
        //                "lspSettings": []
        //            }
        //        ],
        //        "settings": {
        //            "autogenDepositAddresses": false,
        //            "hideBalances": false,
        //            "confirmBeforePlaceOrder": false,
        //            "tickerTapeScroll": true,
        //            "updatesFlash": true,
        //            "notifyOrderFills": false,
        //            "notifyAnnouncements": false,
        //            "notifyMarginUsage": false,
        //            "marginUsageThreshold": "0.5",
        //            "notifyWithdrawals": true,
        //            "notifyDeposits": true,
        //            "notifySendEmail": true,
        //            "notifyRebates": true,
        //            "notifyCommissions": true,
        //            "allowSequenceEmails": true,
        //            "language": "en"
        //        },
        //        "airdropKycAt": null
        //    }
        //
        object subAccounts = this.safeList(response, "subaccounts", new List<object>() {});
        return this.parseAccounts(subAccounts, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //            {
        //                "id": "0",
        //                "name": "Primary",
        //                "pinned": true,
        //                "isLsp": false,
        //                "futuresEnabled": true,
        //                "payFeesInArkm": false,
        //                "lspSettings": []
        //            }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString(account, "id") },
            { "type", null },
            { "code", null },
            { "info", account },
        };
    }

    /**
     * @method
     * @name arkham#fetchBalance
     * @description query for account info
     * @see https://arkm.com/docs#get/account/balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetAccountBalances(parameters);
        //
        //    [
        //        {
        //            "subaccountId": "0",
        //            "symbol": "USDT",
        //            "balance": "19.66494694",
        //            "free": "19.66494694",
        //            "priceUSDT": "1",
        //            "balanceUSDT": "19.66494694",
        //            "freeUSDT": "19.66494694",
        //            "lastUpdateReason": "orderFill",
        //            "lastUpdateTime": "1753773952039342",
        //            "lastUpdateId": "248507437",
        //            "lastUpdateAmount": "7.77252"
        //        },
        //        {
        //            "subaccountId": "0",
        //            "symbol": "SOL",
        //            "balance": "0",
        //            "free": "0",
        //            "priceUSDT": "186.025584673",
        //            "balanceUSDT": "0",
        //            "freeUSDT": "0",
        //            "lastUpdateReason": "orderFill",
        //            "lastUpdateTime": "1753773952039342",
        //            "lastUpdateId": "248507435",
        //            "lastUpdateAmount": "-0.042"
        //        }
        //    ]
        //
        return this.parseBalance(response);
    }

    public override object parseBalance(object response)
    {
        object timestamp = this.safeIntegerProduct(response, "lastUpdateTime", 0.001);
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object balance = getValue(response, i);
            object symbol = this.safeString(balance, "symbol");
            object code = this.safeCurrencyCode(symbol);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "free");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name arkham#createDepositAddress
     * @description create a currency deposit address
     * @see https://arkm.com/docs#post/account/deposit/addresses/new
     * @param {string} code unified currency code of the currency for the deposit address
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " createDepositAddress() requires a \"network\" param")) ;
        }
        object request = new Dictionary<string, object>() {
            { "chain", networkCode },
        };
        object response = await this.v1PrivatePostAccountDepositAddressesNew(this.extend(request, parameters));
        //
        //    {
        //        "addresses": "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV"
        //    }
        //
        object address = this.safeString(response, "addresses");
        return this.parseDepositAddress(address, this.currency(code));
    }

    /**
     * @method
     * @name arkham#fetchDepositAddressesByNetwork
     * @description fetch the deposit addresses for a currency associated with this account
     * @see https://arkm.com/docs#get/account/deposit/addresses
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}, indexed by the network
     */
    public async override Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDepositAddressesByNetwork() requires a \"network\" param")) ;
        }
        object request = new Dictionary<string, object>() {
            { "chain", this.networkCodeToId(networkCode) },
        };
        object response = await this.v1PrivateGetAccountDepositAddresses(this.extend(request, parameters));
        //
        //    {
        //        "addresses": [
        //            "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV"
        //        ]
        //    }
        //
        object data = this.safeList(response, "addresses");
        object parsed = this.parseDepositAddresses(data, null, false, new Dictionary<string, object>() {
            { "network", networkCode },
        });
        return this.indexBy(parsed, "network");
    }

    public override object parseDepositAddress(object entry, object currency = null)
    {
        //
        //     "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV"
        //
        return new Dictionary<string, object>() {
            { "info", entry },
            { "currency", this.safeString(currency, "code") },
            { "network", null },
            { "address", entry },
            { "tag", null },
        };
    }

    /**
     * @method
     * @name arkham#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://arkm.com/docs#get/account/deposit/addresses
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCodeAndParams = this.handleNetworkCodeAndParams(parameters);
        object networkCode = getValue(networkCodeAndParams, 0);
        object indexedAddresses = await this.fetchDepositAddressesByNetwork(code, parameters);
        object selectedNetworkCode = this.selectNetworkCodeFromUnifiedNetworks(getValue(currency, "code"), networkCode, indexedAddresses);
        object address = this.safeDict(indexedAddresses, selectedNetworkCode);
        if (isTrue(isEqual(address, null)))
        {
            throw new InvalidAddress ((string)add(add(this.id, " fetchDepositAddress() could not find a deposit address for "), code)) ;
        }
        return address;
    }

    /**
     * @method
     * @name arkham#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://arkm.com/docs#get/account/deposits
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetAccountDeposits(this.extend(request, parameters));
        //
        //    [
        //        {
        //            "id": "238644",
        //            "symbol": "SOL",
        //            "amount": "0.104",
        //            "time": "1753436404000000",
        //            "confirmed": true,
        //            "transactionHash": "1DRxbbyePTsMuB82SDf2fG5gLXH5iYnY8TQDstDPLULpLtjMJtF1ug1T4Mf8B6DSb8fp2sb5YtdbyqieZ2tkE1Ve",
        //            "chain": "Solana",
        //            "depositAddress": "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV",
        //            "price": "180.322010164"
        //        }
        //    ]
        //
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        return this.parseTransactions(response, currency, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //        {
        //            "id": "238644",
        //            "symbol": "SOL",
        //            "amount": "0.104",
        //            "time": "1753436404000000",
        //            "confirmed": true,
        //            "transactionHash": "1DRxbbyePTsMuB82SDf2fG5gLXH5iYnY8TQDstDPLULpLtjMJtF1ug1T4Mf8B6DSb8fp2sb5YtdbyqieZ2tkE1Ve",
        //            "chain": "Solana",
        //            "depositAddress": "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV",
        //            "price": "180.322010164"
        //        }
        //
        object address = this.safeString(transaction, "depositAddress");
        object timestamp = this.safeIntegerProduct(transaction, "time", 0.001);
        object confirmd = this.safeBool(transaction, "confirmed");
        object status = null;
        if (isTrue(confirmd))
        {
            status = "ok";
        }
        object currencyId = this.safeString(transaction, "symbol");
        object code = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString(transaction, "id") },
            { "txid", this.safeString(transaction, "transactionHash") },
            { "type", null },
            { "currency", code },
            { "network", this.networkIdToCode(this.safeString(transaction, "chain")) },
            { "amount", this.safeNumber(transaction, "amount") },
            { "status", status },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", address },
            { "tag", null },
            { "tagFrom", null },
            { "tagTo", null },
            { "updated", null },
            { "comment", null },
            { "fee", null },
            { "internal", false },
        };
    }

    /**
     * @method
     * @name arkham#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://arkm.com/docs#get/account/fees
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v1PrivateGetAccountFees(parameters);
        //
        // {
        //   "perpMakerFee": "1.23",
        //   "perpTakerFee": "1.23",
        //   "spotMakerFee": "1.23",
        //   "spotTakerFee": "1.23"
        // }
        //
        object symbols = new List<object>(((IDictionary<string,object>)this.markets).Keys);
        object result = new Dictionary<string, object>() {};
        object spotMaker = this.safeNumber(response, "spotMakerFee");
        object spotTaker = this.safeNumber(response, "spotTakerFee");
        object perpMaker = this.safeNumber(response, "perpMakerFee");
        object perpTaker = this.safeNumber(response, "perpTakerFee");
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = getValue(this.markets, symbol);
            ((IDictionary<string,object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
            };
            if (isTrue(getValue(market, "spot")))
            {
                ((IDictionary<string,object>)getValue(result, symbol))["maker"] = spotMaker;
                ((IDictionary<string,object>)getValue(result, symbol))["taker"] = spotTaker;
            } else if (isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))))
            {
                ((IDictionary<string,object>)getValue(result, symbol))["maker"] = perpMaker;
                ((IDictionary<string,object>)getValue(result, symbol))["taker"] = perpTaker;
            }
        }
        return result;
    }

    /**
     * @method
     * @name arkham#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://arkm.com/docs#get/account/funding-rate-payments
     * @param {string} [symbol] unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.v1PrivateGetAccountFundingRatePayments(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "amount": "20.1",
        //             "assetSymbol": "BTC",
        //             "indexPrice": "1.23",
        //             "pairSymbol": "BTC_USDT",
        //             "time": 1704067200000000,
        //             "id": 1,
        //             "subaccountId": 1,
        //             "userId": 1
        //         },
        //         ...
        //     ]
        //
        return this.parseIncomes(response, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //         {
        //             "amount": "20.1",
        //             "assetSymbol": "BTC",
        //             "indexPrice": "1.23",
        //             "pairSymbol": "BTC_USDT",
        //             "time": 1704067200000000,
        //             "id": 1,
        //             "subaccountId": 1,
        //             "userId": 1
        //         }
        //
        object marketId = this.safeString(income, "pairSymbol");
        object currencyId = this.safeString(income, "assetSymbol");
        object timestamp = this.safeIntegerProduct(income, "time", 0.001);
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", this.safeSymbol(marketId, market) },
            { "code", this.safeCurrencyCode(currencyId) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", this.safeString(income, "id") },
            { "amount", this.safeNumber(income, "amount") },
        };
    }

    /**
     * @method
     * @name arkham#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://arkm.com/docs#get/account/leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = this.safeString(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
        };
        object response = await this.v1PrivateGetAccountLeverage(this.extend(request, parameters));
        //
        // might be empty if not changed from default value (which is 1x)
        //
        //    [
        //        {
        //            "symbol": "BTC_USDT_PERP",
        //            "leverage": "7"
        //        },
        //        {
        //            "symbol": "ETH_USDT_PERP",
        //            "leverage": "5"
        //        }
        //    ]
        //
        object indexed = this.indexBy(response, "symbol");
        object data = this.safeDict(indexed, marketId, new Dictionary<string, object>() {});
        return this.parseLeverage(data, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        //
        //        {
        //            "symbol": "ETH_USDT_PERP",
        //            "leverage": "5"
        //        }
        //
        object marketId = this.safeString(leverage, "symbol");
        object leverageNum = this.safeNumber(leverage, "leverage"); // default leverage is 1 typically
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", null },
            { "longLeverage", leverageNum },
            { "shortLeverage", leverageNum },
        };
    }

    /**
     * @method
     * @name arkham#setLeverage
     * @description set the level of leverage for a market
     * @see https://arkm.com/docs#post/account/leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object leverageString = this.numberToString(leverage);
        object marketId = this.safeString(market, "id");
        object request = new Dictionary<string, object>() {
            { "symbol", marketId },
            { "leverage", leverageString },
        };
        object response = await this.v1PrivatePostAccountLeverage(this.extend(request, parameters));
        //
        // response is just empty string
        //
        return this.parseLeverage(response, market);
    }

    /**
     * @method
     * @name arkkm#fetchPositions
     * @description fetch all open positions
     * @see https://arkm.com/docs#get/account/positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.standard] whether to fetch standard contract positions
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v1PrivateGetAccountPositions(parameters);
        //
        //    [
        //        {
        //            "subaccountId": "0",
        //            "symbol": "SOL_USDT_PERP",
        //            "base": "0.037",
        //            "quote": "-6.44614",
        //            "openBuySize": "0",
        //            "openSellSize": "0",
        //            "openBuyNotional": "0",
        //            "openSellNotional": "0",
        //            "lastUpdateReason": "orderFill",
        //            "lastUpdateTime": "1753903829389966",
        //            "lastUpdateId": "250434684",
        //            "lastUpdateBaseDelta": "0.037",
        //            "lastUpdateQuoteDelta": "-6.44614",
        //            "breakEvenPrice": "174.22",
        //            "markPrice": "174.33",
        //            "value": "6.45021",
        //            "pnl": "0.00407",
        //            "initialMargin": "0.645021",
        //            "maintenanceMargin": "0.3870126",
        //            "averageEntryPrice": "174.22"
        //        }
        //    ]
        //
        return this.parsePositions(response, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //        {
        //            "subaccountId": "0",
        //            "symbol": "SOL_USDT_PERP",
        //            "base": "0.037",                             // negative for short position
        //            "quote": "-6.44614",                         // negative for long position
        //            "openBuySize": "0",
        //            "openSellSize": "0",
        //            "openBuyNotional": "0",
        //            "openSellNotional": "0",
        //            "lastUpdateReason": "orderFill",
        //            "lastUpdateTime": "1753903829389966",
        //            "lastUpdateId": "250434684",
        //            "lastUpdateBaseDelta": "0.037",
        //            "lastUpdateQuoteDelta": "-6.44614",
        //            "breakEvenPrice": "174.22",
        //            "markPrice": "174.33",
        //            "value": "6.45021",
        //            "pnl": "0.00407",
        //            "initialMargin": "0.645021",
        //            "maintenanceMargin": "0.3870126",
        //            "averageEntryPrice": "174.22"
        //        }
        //
        object bs = this.safeString(position, "base");
        object baseAbs = Precise.stringAbs(bs);
        object isLong = Precise.stringGe(bs, "0");
        object side = ((bool) isTrue(isLong)) ? "long" : "short";
        object marketId = this.safeString(position, "symbol");
        object notional = this.safeString(position, "value");
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeSymbol(marketId, market) },
            { "notional", this.parseNumber(Precise.stringAbs(notional)) },
            { "marginMode", null },
            { "liquidationPrice", null },
            { "entryPrice", this.safeNumber(position, "averageEntryPrice") },
            { "unrealizedPnl", this.safeNumber(position, "pnl") },
            { "realizedPnl", null },
            { "percentage", null },
            { "contracts", this.parseNumber(baseAbs) },
            { "contractSize", null },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "lastPrice", null },
            { "side", side },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", this.safeInteger(position, "lastUpdateTime") },
            { "maintenanceMargin", this.safeNumber(position, "maintenanceMargin") },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", this.safeNumber(position, "initialMargin") },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name arkkm#withdraw
     * @description make a withdrawal
     * @see https://arkm.com/docs#post/account/withdraw
     * @see https://arkm.com/docs#get/account/withdrawal/addresses
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object withdrawalAddresses = await this.v1PrivateGetAccountWithdrawalAddresses();
        //
        //    [
        //        {
        //            "id": "12345",
        //            "chain": "ETH",
        //            "address": "0x743f79D65EA07AA222F4a83c10dee4210A920a6e",
        //            "label": "my_binance",
        //            "createdAt": "1753905200074355",
        //            "updatedAt": "1753905213464278",
        //            "confirmed": true
        //        }
        //    ]
        //
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
            { "subaccountId", this.safeInteger(parameters, "subAccountId", 0) },
        };
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(isEqual(networkCode, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a \"network\" param")) ;
        }
        object indexedList = this.groupBy(withdrawalAddresses, "address");
        if (!isTrue((inOp(indexedList, address))))
        {
            throw new InvalidAddress ((string)add(this.id, " withdraw() requires an address that has been previously added to the whitelisted addresses")) ;
        }
        object withdrawalObjects = getValue(indexedList, address);
        object foundWithdrawalObject = null;
        for (object i = 0; isLessThan(i, getArrayLength(withdrawalObjects)); postFixIncrement(ref i))
        {
            object withdrawalObject = getValue(withdrawalObjects, i);
            if (isTrue(isEqual(getValue(withdrawalObject, "chain"), networkCode)))
            {
                foundWithdrawalObject = withdrawalObject;
                break;
            }
        }
        if (isTrue(isEqual(foundWithdrawalObject, null)))
        {
            throw new InvalidAddress ((string)add(add(add(add(this.id, " withdraw() can not find whitelisted withdrawal address for "), address), " with network "), networkCode)) ;
        }
        ((IDictionary<string,object>)request)["addressId"] = this.safeInteger(foundWithdrawalObject, "id");
        object response = await this.v1PrivatePostAccountWithdraw(this.extend(request, parameters));
        //
        // response is a weird string like:
        //
        //    "1234709779980\\n"
        //
        object responseString = ((string)response).Replace((string)"\n", (string)"");
        object data = new Dictionary<string, object>() {
            { "id", responseString },
        };
        return this.parseTransaction(data, currency);
    }

    /**
     * @method
     * @name arkham#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
     * @see https://arkm.com/docs#get/public/margin-schedules
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbols, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchLeverageTiers() requires a symbols argument")) ;
        }
        symbols = this.marketSymbols(symbols);
        object response = await this.v1PublicGetMarginSchedules(parameters);
        //
        //    [
        //        {
        //            "name": "A",
        //            "bands": [
        //                {
        //                    "positionLimit": "1000000",
        //                    "leverageRate": "50",
        //                    "marginRate": "0.02",
        //                    "rebate": "0"
        //                },
        //                {
        //                    "positionLimit": "2000000",
        //                    "leverageRate": "25",
        //                    "marginRate": "0.04",
        //                    "rebate": "20000"
        //                },
        //                {
        //                    "positionLimit": "5000000",
        //                    "leverageRate": "20",
        //                    "marginRate": "0.05",
        //                    "rebate": "40000"
        //                }
        //            ]
        //        },
        //        {
        //            "name": "B",
        //            ...
        //
        return this.parseLeverageTiers(response, symbols);
    }

    public override object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        // overloaded method
        object indexed = this.indexBy(response, "name");
        symbols = this.marketSymbols(symbols);
        object tiers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(symbols, i);
            object market = this.market(symbol);
            object marginSchedule = this.safeString(getValue(market, "info"), "marginSchedule");
            if (isTrue(isEqual(marginSchedule, null)))
            {
                throw new BadSymbol ((string)add(add(this.id, " fetchLeverageTiers() could not find marginSchedule for "), symbol)) ;
            }
            object selectedDict = this.safeDict(indexed, marginSchedule, new Dictionary<string, object>() {});
            object bands = this.safeList(selectedDict, "bands", new List<object>() {});
            ((IDictionary<string,object>)tiers)[(string)symbol] = this.parseMarketLeverageTiers(bands, market);
        }
        return tiers;
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        object tiers = new List<object>() {};
        object brackets = info;
        object minNotional = 0;
        for (object i = 0; isLessThan(i, getArrayLength(brackets)); postFixIncrement(ref i))
        {
            object tier = getValue(brackets, i);
            object marketId = this.safeString(info, "market");
            market = this.safeMarket(marketId, market, null, "swap");
            object maxNotional = this.safeNumber(tier, "positionLimit");
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "symbol", this.safeSymbol(marketId, market, null, "swap") },
                { "currency", ((bool) isTrue(getValue(market, "linear"))) ? getValue(market, "base") : getValue(market, "quote") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber(tier, "marginRate") },
                { "maxLeverage", this.safeInteger(tier, "leverageRate") },
                { "info", tier },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public virtual object findTimeframeByDuration(object duration)
    {
        // this method is used to find the timeframe by duration in seconds
        object timeframes = this.safeDict(this.options, "timeframeDurations", new Dictionary<string, object>() {});
        object keys = new List<object>(((IDictionary<string,object>)timeframes).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object timeframe = getValue(keys, i);
            object durationInMicroseconds = this.safeInteger(timeframes, timeframe);
            if (isTrue(isEqual(durationInMicroseconds, duration)))
            {
                return timeframe;
            }
        }
        return null;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object type = this.safeString(api, 0);
        object access = this.safeString(api, 1);
        object accessPart = ((bool) isTrue((isEqual(access, "public")))) ? add(access, "/") : "";
        object query = this.omit(parameters, this.extractParams(path));
        path = this.implodeParams(path, parameters);
        object url = add(add(add(getValue(getValue(this.urls, "api"), type), "/"), accessPart), path);
        object queryString = "";
        if (isTrue(isEqual(method, "GET")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                queryString = this.urlencode(query);
                url = add(url, add("?", queryString));
            }
        }
        if (isTrue(isEqual(access, "private")))
        {
            this.checkRequiredCredentials();
            object expires = multiply((add(this.milliseconds(), this.safeInteger(this.options, "requestExpiration", 5000))), 1000); // need macroseconds
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(parameters);
            }
            if (isTrue(!isEqual(queryString, "")))
            {
                path = add(add(path, "?"), queryString);
            }
            object bodyStr = ((bool) isTrue((!isEqual(body, null)))) ? body : "";
            object payload = add(add(add(add(add(this.apiKey, ((object)expires).ToString()), ((string)method).ToUpper()), "/"), path), bodyStr);
            object decodedSecret = this.base64ToBinary(this.secret);
            object signature = this.hmac(this.encode(payload), decodedSecret, sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
                { "Accept", "application/json" },
                { "Arkham-Api-Key", this.apiKey },
                { "Arkham-Expires", ((object)expires).ToString() },
                { "Arkham-Signature", signature },
                { "Arkham-Broker-Id", "1001" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        //
        // error example:
        //
        //    {
        //        "id": "30005",
        //        "name": "InvalidNotional",
        //        "message": "order validation failed: invalid notional: notional 0.25 is less than min notional 1"
        //    }
        //
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(message, null)))
        {
            object errorCode = this.safeString(response, "id");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return null;
    }
}
