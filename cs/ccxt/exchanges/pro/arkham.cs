namespace ccxt.pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class arkham { public arkham(object args = null) : base(args) { } }
public partial class arkham : ccxt.arkham
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "has", new Dictionary<string, object>() {
                { "ws", true },
                { "watchTrades", true },
                { "watchTradesForSymbols", false },
                { "watchOrderBook", true },
                { "watchOrderBookForSymbols", false },
                { "watchOHLCV", true },
                { "watchOHLCVForSymbols", false },
                { "watchOrders", true },
                { "watchMyTrades", false },
                { "watchTicker", true },
                { "watchTickers", false },
                { "watchBalance", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "api", new Dictionary<string, object>() {
                    { "ws", "wss://arkm.com/ws" },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "watchOrderBook", new Dictionary<string, object>() {
                    { "depth", 100 },
                    { "interval", 500 },
                } },
            } },
            { "streaming", new Dictionary<string, object>() {
                { "keepAlive", 300000 },
            } },
        });
    }

    public override void handleMessage(WebSocketClient client, object message)
    {
        //
        // confirmation
        //
        //     {channel: 'confirmations', confirmationId: 'myCustomId-123'}
        if (isTrue(this.handleErrorMessage(client as WebSocketClient, message)))
        {
            return;
        }
        object methods = new Dictionary<string, object>() {
            { "ticker", this.handleTicker },
            { "candles", this.handleOHLCV },
            { "l2_updates", this.handleOrderBook },
            { "trades", this.handleTrades },
            { "balances", this.handleBalance },
            { "positions", this.handlePositions },
            { "order_statuses", this.handleOrder },
            { "trigger_orders", this.handleOrder },
        };
        object channel = this.safeString(message, "channel");
        if (isTrue(isEqual(channel, "confirmations")))
        {
            return;
        }
        // const type = this.safeString (message, 'type');
        // if (type !== 'update' && type !== 'snapshot') {
        //     debugger;
        // }
        object method = this.safeValue(methods, channel);
        if (isTrue(!isEqual(method, null)))
        {
            DynamicInvoker.InvokeMethod(method, new object[] { client, message});
        }
    }

    public async virtual Task<object> subscribe(object messageHash, object rawChannel, object parameters)
    {
        object subscriptionHash = messageHash;
        object request = new Dictionary<string, object>() {
            { "args", new Dictionary<string, object>() {
                { "channel", rawChannel },
                { "params", parameters },
            } },
            { "confirmationId", this.uuid() },
            { "method", "subscribe" },
        };
        return await this.watch(getValue(getValue(this.urls, "api"), "ws"), messageHash, request, subscriptionHash);
    }

    /**
     * @method
     * @name arkham#watchTicker
     * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://arkm.com/docs#stream/ticker
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object requestArg = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object messageHash = add("ticker::", getValue(market, "symbol"));
        return await this.subscribe(messageHash, "ticker", this.extend(parameters, requestArg));
    }

    public virtual void handleTicker(WebSocketClient client, object message)
    {
        //
        // {
        //   channel: 'ticker',
        //   type: 'update',
        //   data: {
        //     symbol: 'BTC_USDT',
        //     baseSymbol: 'BTC',
        //     quoteSymbol: 'USDT',
        //     price: '118962.74',
        //     price24hAgo: '118780.42',
        //     high24h: '120327.96',
        //     low24h: '118217.28',
        //     volume24h: '32.89729',
        //     quoteVolume24h: '3924438.7146048',
        //     markPrice: '0',
        //     indexPrice: '118963.080293501',
        //     fundingRate: '0',
        //     nextFundingRate: '0',
        //     nextFundingTime: 0,
        //     productType: 'spot',
        //     openInterest: '0',
        //     indexCurrency: 'USDT',
        //     usdVolume24h: '3924438.7146048',
        //     openInterestUSD: '0'
        //   }
        // }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object ticker = this.parseWsTicker(data, market);
        ((IDictionary<string,object>)this.tickers)[(string)symbol] = ticker;
        callDynamically(client as WebSocketClient, "resolve", new object[] {ticker, add("ticker::", symbol)});
    }

    public virtual object parseWsTicker(object message, object market = null)
    {
        // same dict as REST api
        return this.parseTicker(message, market);
    }

    /**
     * @method
     * @name arkham#watchOHLCV
     * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://arkm.com/docs#stream/candles
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object rawTimeframe = this.safeString(this.timeframes, timeframe, timeframe);
        object requestArg = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "duration", rawTimeframe },
        };
        object messageHash = add(add(add("ohlcv::", getValue(market, "symbol")), "::"), rawTimeframe);
        object result = await this.subscribe(messageHash, "candles", this.extend(requestArg, parameters));
        object ohlcv = result;
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(ohlcv, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySinceLimit(ohlcv, since, limit, 0, true);
    }

    public virtual object handleOHLCV(WebSocketClient client, object message)
    {
        //
        // {
        //   channel: 'candles',
        //   type: 'update',
        //   data: {
        //     symbol: 'BTC_USDT',
        //     time: '1755076380000000',
        //     duration: 60000000,
        //     open: '120073.01',
        //     high: '120073.01',
        //     low: '120073.01',
        //     close: '120073.01',
        //     volume: '0',
        //     quoteVolume: '0'
        //   }
        // }
        //
        object data = this.safeDict(message, "data", new Dictionary<string, object>() {});
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId, null);
        object symbol = getValue(market, "symbol");
        object duration = this.safeInteger(data, "duration");
        object timeframe = this.findTimeframeByDuration(duration);
        object messageHash = add(add(add("ohlcv::", symbol), "::"), timeframe);
        ((IDictionary<string,object>)this.ohlcvs)[(string)symbol] = this.safeValue(this.ohlcvs, symbol, new Dictionary<string, object>() {});
        if (!isTrue((inOp(getValue(this.ohlcvs, symbol), timeframe))))
        {
            object limit = this.handleOption("watchOHLCV", "limit", 1000);
            ((IDictionary<string,object>)getValue(this.ohlcvs, symbol))[(string)timeframe] = new ArrayCacheByTimestamp(limit);
        }
        object stored = getValue(getValue(this.ohlcvs, symbol), timeframe);
        object parsed = this.parseWsOHLCV(data, market);
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, messageHash});
        return message;
    }

    public override object parseWsOHLCV(object ohlcv, object market = null)
    {
        // same as REST api
        return this.parseOHLCV(ohlcv, market);
    }

    /**
     * @method
     * @name arkham#watchOrderBook
     * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://arkm.com/docs#stream/l2_updates
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object requestArg = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "snapshot", true },
        };
        object messageHash = add("orderBook::", getValue(market, "symbol"));
        object orderbook = await this.subscribe(messageHash, "l2_updates", this.extend(requestArg, parameters));
        return (orderbook as IOrderBook).limit();
    }

    public virtual void handleOrderBook(WebSocketClient client, object message)
    {
        //
        // snapshot:
        //
        // {
        //     channel: 'l2_updates',
        //     type: 'snapshot',
        //     data: {
        //         symbol: 'BTC_USDT',
        //         group: '0.01',
        //         asks: [  [Object], [Object], ... ],
        //         bids: [  [Object], [Object], ... ],
        //         lastTime: 1755115180608299
        //     }
        // }
        //
        // update:
        //
        // {
        //   channel: "l2_updates",
        //   type: "update",
        //   data: {
        //     symbol: "BTC_USDT",
        //     group: "0.01",
        //     side: "sell",
        //     size: "0.05295",
        //     price: "122722.76",
        //     revisionId: 2455511217,
        //     time: 1755115736475207,
        //   }
        // }
        //
        object data = this.safeDict(message, "data");
        object type = this.safeString(message, "type");
        object marketId = this.safeString(data, "symbol");
        object market = this.safeMarket(marketId);
        object symbol = getValue(market, "symbol");
        object messageHash = add("orderBook::", symbol);
        if (!isTrue((inOp(this.orderbooks, symbol))))
        {
            object ob = this.orderBook(new Dictionary<string, object>() {});
            ((IDictionary<string,object>)ob)["symbol"] = symbol;
            ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = ob;
        }
        object orderbook = getValue(this.orderbooks, symbol);
        if (isTrue(isEqual(type, "snapshot")))
        {
            object timestamp = this.safeIntegerProduct(data, "lastTime", 0.001);
            object parsedOrderBook = this.parseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "size");
            (orderbook as IOrderBook).reset(parsedOrderBook);
        } else if (isTrue(isEqual(type, "update")))
        {
            object timestamp = this.safeIntegerProduct(data, "time", 0.001);
            object side = this.safeString(data, "side");
            object bookside = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(orderbook, "bids") : getValue(orderbook, "asks");
            this.handleDelta(bookside, data);
            ((IDictionary<string,object>)orderbook)["timestamp"] = timestamp;
            ((IDictionary<string,object>)orderbook)["datetime"] = this.iso8601(timestamp);
        }
        ((IDictionary<string,object>)this.orderbooks)[(string)symbol] = orderbook;
        callDynamically(client as WebSocketClient, "resolve", new object[] {getValue(this.orderbooks, symbol), messageHash});
    }

    public override void handleDelta(object bookside, object delta)
    {
        object bidAsk = this.parseBidAsk(delta, "price", "size");
        (bookside as IOrderBookSide).storeArray(bidAsk);
    }

    /**
     * @method
     * @name arkham#watchTrades
     * @description watches information on multiple trades made in a market
     * @see https://arkm.com/docs#stream/trades
     * @param {string} symbol unified market symbol of the market trades were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of trade structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object requestArg = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object messageHash = add("trade::", getValue(market, "symbol"));
        object trades = await this.subscribe(messageHash, "trades", this.extend(requestArg, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(trades, "getLimit", new object[] {getValue(market, "symbol"), limit});
        }
        return this.filterBySinceLimit(trades, since, limit, "timestamp", true);
    }

    public virtual void handleTrades(WebSocketClient client, object message)
    {
        //
        // {
        //     channel: 'trades',
        //     type: 'update',
        //     data: {
        //         symbol: 'BTC_USDT',
        //         revisionId: 2643896903,
        //         size: '0.00261',
        //         price: '118273.2',
        //         takerSide: 'buy',
        //         time: 1755200320146389
        //     }
        // }
        //
        object data = this.safeDict(message, "data");
        object marketId = this.safeString(data, "symbol");
        object symbol = this.safeSymbol(marketId);
        if (!isTrue((inOp(this.trades, symbol))))
        {
            object limit = this.safeInteger(this.options, "tradesLimit", 1000);
            ((IDictionary<string,object>)this.trades)[(string)symbol] = new ArrayCache(limit);
        }
        object parsed = this.parseWsTrade(data);
        object stored = getValue(this.trades, symbol);
        callDynamically(stored, "append", new object[] {parsed});
        callDynamically(client as WebSocketClient, "resolve", new object[] {stored, add("trade::", symbol)});
    }

    public override object parseWsTrade(object trade, object market = null)
    {
        // same as REST api
        return this.parseTrade(trade, market);
    }

    public async virtual Task authenticate(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredCredentials();
        object expires = multiply((add(this.milliseconds(), this.safeInteger(this.options, "requestExpiration", 5000))), 1000); // need macroseconds
        object wsOptions = this.safeDict(this.options, "ws", new Dictionary<string, object>() {});
        object authenticated = this.safeString(wsOptions, "token");
        if (isTrue(isEqual(authenticated, null)))
        {
            object method = "GET";
            object bodyStr = "";
            object path = "ws";
            object payload = add(add(add(add(add(this.apiKey, ((object)expires).ToString()), ((string)method).ToUpper()), "/"), path), bodyStr);
            object decodedSecret = this.base64ToBinary(this.secret);
            object signature = this.hmac(this.encode(payload), decodedSecret, sha256, "base64");
            object defaultOptions = new Dictionary<string, object>() {
                { "ws", new Dictionary<string, object>() {
                    { "options", new Dictionary<string, object>() {
                        { "headers", new Dictionary<string, object>() {
                            { "Content-Type", "application/json" },
                            { "Accept", "application/json" },
                            { "Arkham-Api-Key", this.apiKey },
                            { "Arkham-Expires", ((object)expires).ToString() },
                            { "Arkham-Signature", signature },
                        } },
                    } },
                } },
            };
            this.extendExchangeOptions(defaultOptions);
            this.client(getValue(getValue(this.urls, "api"), "ws"));
        }
    }

    /**
     * @method
     * @name arkham#watchBalance
     * @description watch balance and get the amount of funds available for trading or funds locked in orders
     * @see https://arkm.com/docs#stream/balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate();
        await this.loadMarkets();
        object requestArg = new Dictionary<string, object>() {
            { "snapshot", true },
        };
        object messageHash = "balances";
        object result = await this.subscribe(messageHash, "balances", this.extend(requestArg, parameters));
        return result;
    }

    public virtual void handleBalance(WebSocketClient client, object message)
    {
        //
        // snapshot:
        //
        //     {
        //         channel: 'balances',
        //         type: 'snapshot',
        //         data: [
        //           {
        //             subaccountId: 0,
        //             symbol: 'USDT',
        //             balance: '7.035335375',
        //             free: '7.035335375',
        //             priceUSDT: '1',
        //             balanceUSDT: '7.035335375',
        //             freeUSDT: '7.035335375',
        //             lastUpdateReason: 'withdrawalFee',
        //             lastUpdateTime: '1753905990432678',
        //             lastUpdateId: 250483404,
        //             lastUpdateAmount: '-2'
        //           },
        //           {
        //             subaccountId: 0,
        //             symbol: 'SOL',
        //             balance: '0.03',
        //             free: '0.03',
        //             priceUSDT: '197.37823276',
        //             balanceUSDT: '5.921346982',
        //             freeUSDT: '5.921346982',
        //             lastUpdateReason: 'orderFill',
        //             lastUpdateTime: '1753777760560164',
        //             lastUpdateId: 248588190,
        //             lastUpdateAmount: '0.03'
        //           }
        //         ]
        //     }
        //
        // update:
        //
        //     {
        //         channel: 'balances',
        //         type: 'update',
        //         data: {
        //             subaccountId: 0,
        //             symbol: 'USDT',
        //             balance: '7.028357615',
        //             free: '7.028357615',
        //             priceUSDT: '1',
        //             balanceUSDT: '7.028357615',
        //             freeUSDT: '7.028357615',
        //             lastUpdateReason: 'tradingFee',
        //             lastUpdateTime: '1755240882544056',
        //             lastUpdateId: 2697860787,
        //             lastUpdateAmount: '-0.00697776'
        //         }
        //     }
        //
        object type = this.safeString(message, "type");
        object parsed = new Dictionary<string, object>() {};
        if (isTrue(isEqual(type, "snapshot")))
        {
            // response same as REST api
            object data = this.safeList(message, "data");
            parsed = this.parseWsBalance(data);
            ((IDictionary<string,object>)parsed)["info"] = message;
            this.balance = parsed;
        } else
        {
            object data = this.safeDict(message, "data");
            object balancesArray = new List<object>() {data};
            parsed = this.parseWsBalance(balancesArray);
            object currencyId = this.safeString(data, "symbol");
            object code = this.safeCurrencyCode(currencyId);
            ((IDictionary<string,object>)this.balance)[(string)code] = getValue(parsed, code);
        }
        object messageHash = "balances";
        callDynamically(client as WebSocketClient, "resolve", new object[] {this.safeBalance(this.balance), messageHash});
    }

    public virtual object parseWsBalance(object balance)
    {
        // same as REST api
        return this.parseBalance(balance);
    }

    /**
     * @method
     * @name arkham#watchPositions
     * @see https://arkm.com/docs#stream/positions
     * @description watch all open positions
     * @param {string[]} [symbols] list of unified market symbols
     * @param {int} [since] the earliest time in ms to fetch positions for
     * @param {int} [limit] the maximum number of positions to retrieve
     * @param {object} params extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
     */
    public async override Task<object> watchPositions(object symbols = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate();
        await this.loadMarkets();
        object messageHash = "positions";
        if (!isTrue(this.isEmpty(symbols)))
        {
            symbols = this.marketSymbols(symbols);
            messageHash = add(messageHash, add("::", String.Join(",", ((IList<object>)symbols).ToArray())));
        }
        this.positions = new ArrayCacheBySymbolBySide();
        object requestArg = new Dictionary<string, object>() {
            { "snapshot", false },
        };
        object newPositions = await this.subscribe(messageHash, "positions", this.extend(requestArg, parameters));
        if (isTrue(this.newUpdates))
        {
            return newPositions;
        }
        return this.filterBySymbolsSinceLimit(this.positions, symbols, since, limit, true);
    }

    public virtual void handlePositions(WebSocketClient client, object message)
    {
        //
        // snapshot:
        //
        //     {
        //         channel: 'positions',
        //         type: 'snapshot',
        //         data: [
        //           {
        //             subaccountId: 0,
        //             symbol: 'SOL_USDT_PERP',
        //             base: '0.059',
        //             quote: '-11.50618',
        //             openBuySize: '0',
        //             openSellSize: '0',
        //             openBuyNotional: '0',
        //             openSellNotional: '0',
        //             lastUpdateReason: 'orderFill',
        //             lastUpdateTime: '1755251065621402',
        //             lastUpdateId: 2709589783,
        //             lastUpdateBaseDelta: '0.059',
        //             lastUpdateQuoteDelta: '-11.50618',
        //             breakEvenPrice: '195.02',
        //             markPrice: '195',
        //             value: '11.505',
        //             pnl: '-0.00118',
        //             initialMargin: '1.1505',
        //             maintenanceMargin: '0.6903',
        //             averageEntryPrice: '195.02'
        //           }
        //         ]
        //     }
        //
        object newPositions = new List<object>() {};
        if (isTrue(isEqual(this.positions, null)))
        {
            this.positions = new Dictionary<string, object>() {};
        }
        object type = this.safeString(message, "type");
        if (isTrue(isEqual(type, "snapshot")))
        {
            object data = this.safeList(message, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object position = this.parseWsPosition(getValue(data, i));
                if (isTrue(!isEqual(this.safeInteger(position, "entryPrice"), 0)))
                {
                    ((IList<object>)newPositions).Add(position);
                    object symbol = this.safeString(position, "symbol");
                    ((IDictionary<string,object>)this.positions)[(string)symbol] = position;
                }
            }
        } else
        {
            object data = this.safeDict(message, "data");
            object position = this.parseWsPosition(data);
            object symbol = this.safeString(position, "symbol");
            ((IDictionary<string,object>)this.positions)[(string)symbol] = position;
            ((IList<object>)newPositions).Add(position);
        }
        object messageHashes = this.findMessageHashes(client as WebSocketClient, "positions::");
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            object parts = ((string)messageHash).Split(new [] {((string)"::")}, StringSplitOptions.None).ToList<object>();
            object symbolsString = getValue(parts, 1);
            object symbols = ((string)symbolsString).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>();
            object positions = this.filterByArray(newPositions, "symbol", symbols, false);
            if (!isTrue(this.isEmpty(positions)))
            {
                callDynamically(client as WebSocketClient, "resolve", new object[] {positions, messageHash});
            }
        }
        object length = getArrayLength(newPositions);
        if (isTrue(isGreaterThan(length, 0)))
        {
            callDynamically(client as WebSocketClient, "resolve", new object[] {newPositions, "positions"});
        }
    }

    public virtual object parseWsPositions(object positions, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols);
        positions = this.toArray(positions);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = this.extend(this.parseWsPosition(getValue(positions, i), null), parameters);
            ((IList<object>)result).Add(position);
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public virtual object parseWsPosition(object position, object market = null)
    {
        // same as REST api
        return this.parsePosition(position, market);
    }

    /**
     * @method
     * @name arkham#watchOrders
     * @description watches information on multiple orders made by the user
     * @see https://arkm.com/docs#stream/order_statuses
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.authenticate();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object requestArg = new Dictionary<string, object>() {
            { "snapshot", false },
        };
        object isTriggerOrder = false;
        var isTriggerOrderparametersVariable = this.handleOptionAndParams(parameters, "watchOrders", "trigger", false);
        isTriggerOrder = ((IList<object>)isTriggerOrderparametersVariable)[0];
        parameters = ((IList<object>)isTriggerOrderparametersVariable)[1];
        object rawChannel = ((bool) isTrue(isTriggerOrder)) ? "trigger_orders" : "order_statuses";
        object messageHash = "orders";
        if (isTrue(!isEqual(symbol, null)))
        {
            messageHash = add(messageHash, add("::", getValue(market, "symbol")));
        }
        messageHash = add(messageHash, add("::", rawChannel));
        object orders = await this.subscribe(messageHash, rawChannel, this.extend(requestArg, parameters));
        if (isTrue(this.newUpdates))
        {
            limit = callDynamically(orders, "getLimit", new object[] {symbol, limit});
        }
        return this.filterBySymbolSinceLimit(orders, symbol, since, limit, true);
    }

    public virtual void handleOrder(WebSocketClient client, object message)
    {
        //
        //     {
        //         channel: "order_statuses",
        //         type: "update",
        //         data: {
        //             orderId: 4200775347657,
        //             userId: 2959880,
        //             subaccountId: 0,
        //             symbol: "ARKM_USDT_PERP",
        //             time: "1755253639782186",
        //             side: "buy",
        //             type: "limitGtc",
        //             size: "10",
        //             price: "0.5",
        //             postOnly: false,
        //             reduceOnly: false,
        //             executedSize: "0",
        //             status: "cancelled",
        //             avgPrice: "0",
        //             executedNotional: "0",
        //             creditFeePaid: "0",
        //             marginBonusFeePaid: "0",
        //             quoteFeePaid: "0",
        //             arkmFeePaid: "0",
        //             revisionId: 2752963990,
        //             lastTime: "1755272026403545",
        //             clientOrderId: "",
        //             lastSize: "0",
        //             lastPrice: "0",
        //             lastCreditFee: "0",
        //             lastMarginBonusFee: "0",
        //             lastQuoteFee: "0",
        //             lastArkmFee: "0",
        //         }
        //     }
        //
        object channel = this.safeString(message, "channel");
        object data = this.safeDict(message, "data");
        if (isTrue(isEqual(this.orders, null)))
        {
            object limit = this.safeInteger(this.options, "ordersLimit", 1000);
            this.orders = new ArrayCacheBySymbolById(limit);
        }
        object orders = this.orders;
        object order = this.parseWsOrder(data);
        callDynamically(orders, "append", new object[] {order});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, "orders"});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add(add(add("orders::", getValue(order, "symbol")), "::"), channel)});
        callDynamically(client as WebSocketClient, "resolve", new object[] {orders, add("orders::", channel)});
    }

    public override object parseWsOrder(object order, object market = null)
    {
        // same as REST api
        return this.parseOrder(order, market);
    }

    public virtual object handleErrorMessage(WebSocketClient client, object response)
    {
        //
        // error example:
        //
        //    {
        //        "id": "30005",
        //        "name": "InvalidNotional",
        //        "message": "order validation failed: invalid notional: notional 0.25 is less than min notional 1"
        //    }
        //
        object message = this.safeString(response, "message");
        if (isTrue(!isEqual(message, null)))
        {
            object body = this.json(response);
            object errorCode = this.safeString(response, "id");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return false;
    }
}
