package ccxtpro
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ArkhamCore struct {
	*ccxt.ArkhamCore
	base *ccxt.ArkhamCore
}

func NewArkhamCore() *ArkhamCore {
    p := &ArkhamCore{}
	base := &ccxt.ArkhamCore{}
	p.base = base
	p.ArkhamCore = base
    ccxt.SetDefaults(p)
    return p
}

func  (this *ArkhamCore) Describe() interface{}  {
    return this.DeepExtend(this.base.Describe(), map[string]interface{} {
        "has": map[string]interface{} {
            "ws": true,
            "watchTrades": true,
            "watchTradesForSymbols": false,
            "watchOrderBook": true,
            "watchOrderBookForSymbols": false,
            "watchOHLCV": true,
            "watchOHLCVForSymbols": false,
            "watchOrders": true,
            "watchMyTrades": false,
            "watchTicker": true,
            "watchTickers": false,
            "watchBalance": true,
        },
        "urls": map[string]interface{} {
            "api": map[string]interface{} {
                "ws": "wss://arkm.com/ws",
            },
        },
        "options": map[string]interface{} {
            "watchOrderBook": map[string]interface{} {
                "depth": 100,
                "interval": 500,
            },
        },
        "streaming": map[string]interface{} {
            "keepAlive": 300000,
        },
    })
}
func  (this *ArkhamCore) HandleMessage(client interface{}, message interface{})  {
    //
    // confirmation
    //
    //     {channel: 'confirmations', confirmationId: 'myCustomId-123'}
    if ccxt.IsTrue(this.HandleErrorMessage(client, message)) {
        return
    }
    var methods interface{} = map[string]interface{} {
        "ticker": this.HandleTicker,
        "candles": this.HandleOHLCV,
        "l2_updates": this.HandleOrderBook,
        "trades": this.HandleTrades,
        "balances": this.HandleBalance,
        "positions": this.HandlePositions,
        "order_statuses": this.HandleOrder,
        "trigger_orders": this.HandleOrder,
    }
    var channel interface{} = this.SafeString(message, "channel")
    if ccxt.IsTrue(ccxt.IsEqual(channel, "confirmations")) {
        return
    }
    // const type = this.safeString (message, 'type')
    // if (type !== 'update' && type !== 'snapshot') {
    //     debugger
    // }
    var method interface{} = this.SafeValue(methods, channel)
    if ccxt.IsTrue(!ccxt.IsEqual(method, nil)) {
        ccxt.CallDynamically(method, client, message)
    }
}
func  (this *ArkhamCore) Subscribe(messageHash interface{}, rawChannel interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    var subscriptionHash interface{} = messageHash
            var request interface{} = map[string]interface{} {
                "args": map[string]interface{} {
                    "channel": rawChannel,
                    "params": params,
                },
                "confirmationId": this.Uuid(),
                "method": "subscribe",
            }
        
                retRes8915 :=  (<-this.Watch(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"), messageHash, request, subscriptionHash))
                ccxt.PanicOnError(retRes8915)
                ch <- retRes8915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name arkham#watchTicker
 * @description watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://arkm.com/docs#stream/ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ArkhamCore) WatchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes1028 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1028)
            var market interface{} = this.Market(symbol)
            var requestArg interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
            }
            var messageHash interface{} = ccxt.Add("ticker::", ccxt.GetValue(market, "symbol"))
        
                retRes10815 :=  (<-this.Subscribe(messageHash, "ticker", this.Extend(params, requestArg)))
                ccxt.PanicOnError(retRes10815)
                ch <- retRes10815
                return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandleTicker(client interface{}, message interface{})  {
    //
    // {
    //   channel: 'ticker',
    //   type: 'update',
    //   data: {
    //     symbol: 'BTC_USDT',
    //     baseSymbol: 'BTC',
    //     quoteSymbol: 'USDT',
    //     price: '118962.74',
    //     price24hAgo: '118780.42',
    //     high24h: '120327.96',
    //     low24h: '118217.28',
    //     volume24h: '32.89729',
    //     quoteVolume24h: '3924438.7146048',
    //     markPrice: '0',
    //     indexPrice: '118963.080293501',
    //     fundingRate: '0',
    //     nextFundingRate: '0',
    //     nextFundingTime: 0,
    //     productType: 'spot',
    //     openInterest: '0',
    //     indexCurrency: 'USDT',
    //     usdVolume24h: '3924438.7146048',
    //     openInterestUSD: '0'
    //   }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var ticker interface{} = this.ParseWsTicker(data, market)
    ccxt.AddElementToObject(this.Tickers, symbol, ticker)
    client.(ccxt.ClientInterface).Resolve(ticker, ccxt.Add("ticker::", symbol))
}
func  (this *ArkhamCore) ParseWsTicker(message interface{}, optionalArgs ...interface{}) interface{}  {
    // same dict as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTicker(message, market)
}
/**
 * @method
 * @name arkham#watchOHLCV
 * @description watches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://arkm.com/docs#stream/candles
 * @param {string} symbol unified symbol of the market to fetch ccxt.OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ArkhamCore) WatchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    timeframe := ccxt.GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1698 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes1698)
            var market interface{} = this.Market(symbol)
            var rawTimeframe interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var requestArg interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
                "duration": rawTimeframe,
            }
            var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", ccxt.GetValue(market, "symbol")), "::"), rawTimeframe)
        
            result:= (<-this.Subscribe(messageHash, "candles", this.Extend(requestArg, params)))
            ccxt.PanicOnError(result)
            var ohlcv interface{} = result
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(ohlcv).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySinceLimit(ohlcv, since, limit, 0, true)
            return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandleOHLCV(client interface{}, message interface{}) interface{}  {
    //
    // {
    //   channel: 'candles',
    //   type: 'update',
    //   data: {
    //     symbol: 'BTC_USDT',
    //     time: '1755076380000000',
    //     duration: 60000000,
    //     open: '120073.01',
    //     high: '120073.01',
    //     low: '120073.01',
    //     close: '120073.01',
    //     volume: '0',
    //     quoteVolume: '0'
    //   }
    // }
    //
    var data interface{} = this.SafeDict(message, "data", map[string]interface{} {})
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId, nil)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var duration interface{} = this.SafeInteger(data, "duration")
    var timeframe interface{} = this.FindTimeframeByDuration(duration)
    var messageHash interface{} = ccxt.Add(ccxt.Add(ccxt.Add("ohlcv::", symbol), "::"), timeframe)
    ccxt.AddElementToObject(this.Ohlcvs, symbol, this.SafeValue(this.Ohlcvs, symbol, map[string]interface{} {}))
    if !ccxt.IsTrue((ccxt.InOp(ccxt.GetValue(this.Ohlcvs, symbol), timeframe))) {
        var limit interface{} = this.HandleOption("watchOHLCV", "limit", 1000)
        ccxt.AddElementToObject(ccxt.GetValue(this.Ohlcvs, symbol), timeframe, ccxt.NewArrayCacheByTimestamp(limit))
    }
    var stored interface{} = ccxt.GetValue(ccxt.GetValue(this.Ohlcvs, symbol), timeframe)
    var parsed interface{} = this.ParseWsOHLCV(data, market)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, messageHash)
    return message
}
func  (this *ArkhamCore) ParseWsOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseOHLCV(ohlcv, market)
}
/**
 * @method
 * @name arkham#watchOrderBook
 * @description watches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://arkm.com/docs#stream/l2_updates
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ArkhamCore) WatchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    limit := ccxt.GetArg(optionalArgs, 0, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes2388 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes2388)
            var market interface{} = this.Market(symbol)
            var requestArg interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
                "snapshot": true,
            }
            var messageHash interface{} = ccxt.Add("orderBook::", ccxt.GetValue(market, "symbol"))
        
            orderbook:= (<-this.Subscribe(messageHash, "l2_updates", this.Extend(requestArg, params)))
            ccxt.PanicOnError(orderbook)
        
            ch <- orderbook.(ccxt.OrderBookInterface).Limit()
            return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandleOrderBook(client interface{}, message interface{})  {
    //
    // snapshot:
    //
    // {
    //     channel: 'l2_updates',
    //     type: 'snapshot',
    //     data: {
    //         symbol: 'BTC_USDT',
    //         group: '0.01',
    //         asks: [  [Object], [Object], ... ],
    //         bids: [  [Object], [Object], ... ],
    //         lastTime: 1755115180608299
    //     }
    // }
    //
    // update:
    //
    // {
    //   channel: "l2_updates",
    //   type: "update",
    //   data: {
    //     symbol: "BTC_USDT",
    //     group: "0.01",
    //     side: "sell",
    //     size: "0.05295",
    //     price: "122722.76",
    //     revisionId: 2455511217,
    //     time: 1755115736475207,
    //   }
    // }
    //
    var data interface{} = this.SafeDict(message, "data")
    var typeVar interface{} = this.SafeString(message, "type")
    var marketId interface{} = this.SafeString(data, "symbol")
    var market interface{} = this.SafeMarket(marketId)
    var symbol interface{} = ccxt.GetValue(market, "symbol")
    var messageHash interface{} = ccxt.Add("orderBook::", symbol)
    if !ccxt.IsTrue((ccxt.InOp(this.Orderbooks, symbol))) {
        var ob interface{} = this.OrderBook(map[string]interface{} {})
        ccxt.AddElementToObject(ob, "symbol", symbol)
        ccxt.AddElementToObject(this.Orderbooks, symbol, ob)
    }
    var orderbook interface{} = ccxt.GetValue(this.Orderbooks, symbol)
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
        var timestamp interface{} = this.SafeIntegerProduct(data, "lastTime", 0.001)
        var parsedOrderBook interface{} = this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "size")
        orderbook.(ccxt.OrderBookInterface).Reset(parsedOrderBook)
    } else if ccxt.IsTrue(ccxt.IsEqual(typeVar, "update")) {
        var timestamp interface{} = this.SafeIntegerProduct(data, "time", 0.001)
        var side interface{} = this.SafeString(data, "side")
        var bookside interface{} = ccxt.Ternary(ccxt.IsTrue((ccxt.IsEqual(side, "buy"))), ccxt.GetValue(orderbook, "bids"), ccxt.GetValue(orderbook, "asks"))
        this.HandleDelta(bookside, data)
        ccxt.AddElementToObject(orderbook, "timestamp", timestamp)
        ccxt.AddElementToObject(orderbook, "datetime", this.Iso8601(timestamp))
    }
    ccxt.AddElementToObject(this.Orderbooks, symbol, orderbook)
    client.(ccxt.ClientInterface).Resolve(ccxt.GetValue(this.Orderbooks, symbol), messageHash)
}
func  (this *ArkhamCore) HandleDelta(bookside interface{}, delta interface{})  {
    var bidAsk interface{} = this.ParseBidAsk(delta, "price", "size")
    bookside.(ccxt.IOrderBookSide).StoreArray(bidAsk)
}
/**
 * @method
 * @name arkham#watchTrades
 * @description watches information on multiple trades made in a market
 * @see https://arkm.com/docs#stream/trades
 * @param {string} symbol unified market symbol of the market trades were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *ArkhamCore) WatchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    since := ccxt.GetArg(optionalArgs, 0, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 1, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes3268 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes3268)
            var market interface{} = this.Market(symbol)
            var requestArg interface{} = map[string]interface{} {
                "symbol": ccxt.GetValue(market, "id"),
            }
            var messageHash interface{} = ccxt.Add("trade::", ccxt.GetValue(market, "symbol"))
        
            trades:= (<-this.Subscribe(messageHash, "trades", this.Extend(requestArg, params)))
            ccxt.PanicOnError(trades)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(trades).GetLimit(ccxt.GetValue(market, "symbol"), limit)
            }
        
            ch <- this.FilterBySinceLimit(trades, since, limit, "timestamp", true)
            return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandleTrades(client interface{}, message interface{})  {
    //
    // {
    //     channel: 'trades',
    //     type: 'update',
    //     data: {
    //         symbol: 'BTC_USDT',
    //         revisionId: 2643896903,
    //         size: '0.00261',
    //         price: '118273.2',
    //         takerSide: 'buy',
    //         time: 1755200320146389
    //     }
    // }
    //
    var data interface{} = this.SafeDict(message, "data")
    var marketId interface{} = this.SafeString(data, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    if !ccxt.IsTrue((ccxt.InOp(this.Trades, symbol))) {
        var limit interface{} = this.SafeInteger(this.Options, "tradesLimit", 1000)
        ccxt.AddElementToObject(this.Trades, symbol, ccxt.NewArrayCache(limit))
    }
    var parsed interface{} = this.ParseWsTrade(data)
    var stored interface{} = ccxt.GetValue(this.Trades, symbol)
    stored.(ccxt.Appender).Append(parsed)
    client.(ccxt.ClientInterface).Resolve(stored, ccxt.Add("trade::", symbol))
}
func  (this *ArkhamCore) ParseWsTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseTrade(trade, market)
}
func  (this *ArkhamCore) Authenticate(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var expires interface{} = ccxt.Multiply((ccxt.Add(this.Milliseconds(), this.SafeInteger(this.Options, "requestExpiration", 5000))), 1000) // need macroseconds
            var wsOptions interface{} = this.SafeDict(this.Options, "ws", map[string]interface{} {})
            var authenticated interface{} = this.SafeString(wsOptions, "token")
            if ccxt.IsTrue(ccxt.IsEqual(authenticated, nil)) {
                var method interface{} = "GET"
                var bodyStr interface{} = ""
                var path interface{} = "ws"
                var payload interface{} = ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(ccxt.Add(this.ApiKey, ccxt.ToString(expires)), ccxt.ToUpper(method)), "/"), path), bodyStr)
                var decodedSecret interface{} = this.Base64ToBinary(this.Secret)
                var signature interface{} = this.Hmac(this.Encode(payload), decodedSecret, ccxt.Sha256, "base64")
                var defaultOptions interface{} = map[string]interface{} {
                    "ws": map[string]interface{} {
                        "options": map[string]interface{} {
                            "headers": map[string]interface{} {
                                "Content-Type": "application/json",
                                "Accept": "application/json",
                                "Arkham-Api-Key": this.ApiKey,
                                "Arkham-Expires": ccxt.ToString(expires),
                                "Arkham-Signature": signature,
                            },
                        },
                    },
                }
                this.ExtendExchangeOptions(defaultOptions)
                this.Client(ccxt.GetValue(ccxt.GetValue(this.Urls, "api"), "ws"))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name arkham#watchBalance
 * @description watch balance and get the amount of funds available for trading or funds locked in orders
 * @see https://arkm.com/docs#stream/balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {str} [params.type] spot or contract if not provided this.options['defaultType'] is used
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *ArkhamCore) WatchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    params := ccxt.GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4128 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes4128)
        
            retRes4138 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes4138)
            var requestArg interface{} = map[string]interface{} {
                "snapshot": true,
            }
            var messageHash interface{} = "balances"
        
            result:= (<-this.Subscribe(messageHash, "balances", this.Extend(requestArg, params)))
            ccxt.PanicOnError(result)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandleBalance(client interface{}, message interface{})  {
    //
    // snapshot:
    //
    //     {
    //         channel: 'balances',
    //         type: 'snapshot',
    //         data: [
    //           {
    //             subaccountId: 0,
    //             symbol: 'USDT',
    //             balance: '7.035335375',
    //             free: '7.035335375',
    //             priceUSDT: '1',
    //             balanceUSDT: '7.035335375',
    //             freeUSDT: '7.035335375',
    //             lastUpdateReason: 'withdrawalFee',
    //             lastUpdateTime: '1753905990432678',
    //             lastUpdateId: 250483404,
    //             lastUpdateAmount: '-2'
    //           },
    //           {
    //             subaccountId: 0,
    //             symbol: 'SOL',
    //             balance: '0.03',
    //             free: '0.03',
    //             priceUSDT: '197.37823276',
    //             balanceUSDT: '5.921346982',
    //             freeUSDT: '5.921346982',
    //             lastUpdateReason: 'orderFill',
    //             lastUpdateTime: '1753777760560164',
    //             lastUpdateId: 248588190,
    //             lastUpdateAmount: '0.03'
    //           }
    //         ]
    //     }
    //
    // update:
    //
    //     {
    //         channel: 'balances',
    //         type: 'update',
    //         data: {
    //             subaccountId: 0,
    //             symbol: 'USDT',
    //             balance: '7.028357615',
    //             free: '7.028357615',
    //             priceUSDT: '1',
    //             balanceUSDT: '7.028357615',
    //             freeUSDT: '7.028357615',
    //             lastUpdateReason: 'tradingFee',
    //             lastUpdateTime: '1755240882544056',
    //             lastUpdateId: 2697860787,
    //             lastUpdateAmount: '-0.00697776'
    //         }
    //     }
    //
    var typeVar interface{} = this.SafeString(message, "type")
    var parsed interface{} = map[string]interface{} {}
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
        // response same as REST api
        var data interface{} = this.SafeList(message, "data")
        parsed = this.ParseWsBalance(data)
        ccxt.AddElementToObject(parsed, "info", message)
        this.Balance = parsed
    } else {
        var data interface{} = this.SafeDict(message, "data")
        var balancesArray interface{} = []interface{}{data}
        parsed = this.ParseWsBalance(balancesArray)
        var currencyId interface{} = this.SafeString(data, "symbol")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        ccxt.AddElementToObject(this.Balance, code, ccxt.GetValue(parsed, code))
    }
    var messageHash interface{} = "balances"
    client.(ccxt.ClientInterface).Resolve(this.SafeBalance(this.Balance), messageHash)
}
func  (this *ArkhamCore) ParseWsBalance(balance interface{}) interface{}  {
    // same as REST api
    return this.ParseBalance(balance)
}
/**
 * @method
 * @name arkham#watchPositions
 * @see https://arkm.com/docs#stream/positions
 * @description watch all open positions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {int} [since] the earliest time in ms to fetch positions for
 * @param {int} [limit] the maximum number of positions to retrieve
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/en/latest/manual.html#position-structure}
 */
func  (this *ArkhamCore) WatchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbols := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5168 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes5168)
        
            retRes5178 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes5178)
            var messageHash interface{} = "positions"
            if !ccxt.IsTrue(this.IsEmpty(symbols)) {
                symbols = this.MarketSymbols(symbols)
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", ccxt.Join(symbols, ",")))
            }
            this.Positions = ccxt.NewArrayCacheBySymbolBySide()
            var requestArg interface{} = map[string]interface{} {
                "snapshot": false,
            }
        
            newPositions:= (<-this.Subscribe(messageHash, "positions", this.Extend(requestArg, params)))
            ccxt.PanicOnError(newPositions)
            if ccxt.IsTrue(this.NewUpdates) {
        
                ch <- newPositions
                return nil
            }
        
            ch <- this.FilterBySymbolsSinceLimit(this.Positions, symbols, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandlePositions(client interface{}, message interface{})  {
    //
    // snapshot:
    //
    //     {
    //         channel: 'positions',
    //         type: 'snapshot',
    //         data: [
    //           {
    //             subaccountId: 0,
    //             symbol: 'SOL_USDT_PERP',
    //             base: '0.059',
    //             quote: '-11.50618',
    //             openBuySize: '0',
    //             openSellSize: '0',
    //             openBuyNotional: '0',
    //             openSellNotional: '0',
    //             lastUpdateReason: 'orderFill',
    //             lastUpdateTime: '1755251065621402',
    //             lastUpdateId: 2709589783,
    //             lastUpdateBaseDelta: '0.059',
    //             lastUpdateQuoteDelta: '-11.50618',
    //             breakEvenPrice: '195.02',
    //             markPrice: '195',
    //             value: '11.505',
    //             pnl: '-0.00118',
    //             initialMargin: '1.1505',
    //             maintenanceMargin: '0.6903',
    //             averageEntryPrice: '195.02'
    //           }
    //         ]
    //     }
    //
    var newPositions interface{} = []interface{}{}
    if ccxt.IsTrue(ccxt.IsEqual(this.Positions, nil)) {
        this.Positions = map[string]interface{} {}
    }
    var typeVar interface{} = this.SafeString(message, "type")
    if ccxt.IsTrue(ccxt.IsEqual(typeVar, "snapshot")) {
        var data interface{} = this.SafeList(message, "data", []interface{}{})
        for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(data)); i++ {
            var position interface{} = this.ParseWsPosition(ccxt.GetValue(data, i))
            if ccxt.IsTrue(!ccxt.IsEqual(this.SafeInteger(position, "entryPrice"), 0)) {
                ccxt.AppendToArray(&newPositions, position)
                var symbol interface{} = this.SafeString(position, "symbol")
                ccxt.AddElementToObject(this.Positions, symbol, position)
            }
        }
    } else {
        var data interface{} = this.SafeDict(message, "data")
        var position interface{} = this.ParseWsPosition(data)
        var symbol interface{} = this.SafeString(position, "symbol")
        ccxt.AddElementToObject(this.Positions, symbol, position)
        ccxt.AppendToArray(&newPositions, position)
    }
    var messageHashes interface{} = this.FindMessageHashes(client.(*ccxt.Client), "positions::")
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(messageHashes)); i++ {
        var messageHash interface{} = ccxt.GetValue(messageHashes, i)
        var parts interface{} = ccxt.Split(messageHash, "::")
        var symbolsString interface{} = ccxt.GetValue(parts, 1)
        var symbols interface{} = ccxt.Split(symbolsString, ",")
        var positions interface{} = this.FilterByArray(newPositions, "symbol", symbols, false)
        if !ccxt.IsTrue(this.IsEmpty(positions)) {
            client.(ccxt.ClientInterface).Resolve(positions, messageHash)
        }
    }
    var length interface{} =     ccxt.GetArrayLength(newPositions)
    if ccxt.IsTrue(ccxt.IsGreaterThan(length, 0)) {
        client.(ccxt.ClientInterface).Resolve(newPositions, "positions")
    }
}
func  (this *ArkhamCore) ParseWsPositions(positions interface{}, optionalArgs ...interface{}) interface{}  {
    symbols := ccxt.GetArg(optionalArgs, 0, nil)
    _ = symbols
    params := ccxt.GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    symbols = this.MarketSymbols(symbols)
    positions = this.ToArray(positions)
    var result interface{} = []interface{}{}
    for i := 0; ccxt.IsLessThan(i, ccxt.GetArrayLength(positions)); i++ {
        var position interface{} = this.Extend(this.ParseWsPosition(ccxt.GetValue(positions, i), nil), params)
        ccxt.AppendToArray(&result, position)
    }
    return this.FilterByArrayPositions(result, "symbol", symbols, false)
}
func  (this *ArkhamCore) ParseWsPosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParsePosition(position, market)
}
/**
 * @method
 * @name arkham#watchOrders
 * @description watches information on multiple orders made by the user
 * @see https://arkm.com/docs#stream/order_statuses
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ArkhamCore) WatchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ccxt.ReturnPanicError(ch)
                    symbol := ccxt.GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := ccxt.GetArg(optionalArgs, 1, nil)
            _ = since
            limit := ccxt.GetArg(optionalArgs, 2, nil)
            _ = limit
            params := ccxt.GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6348 := (<-this.Authenticate())
            ccxt.PanicOnError(retRes6348)
        
            retRes6358 := (<-this.LoadMarkets())
            ccxt.PanicOnError(retRes6358)
            var market interface{} = nil
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var requestArg interface{} = map[string]interface{} {
                "snapshot": false,
            }
            var isTriggerOrder interface{} = false
            isTriggerOrderparamsVariable := this.HandleOptionAndParams(params, "watchOrders", "trigger", false)
            isTriggerOrder = ccxt.GetValue(isTriggerOrderparamsVariable,0)
            params = ccxt.GetValue(isTriggerOrderparamsVariable,1)
            var rawChannel interface{} = ccxt.Ternary(ccxt.IsTrue(isTriggerOrder), "trigger_orders", "order_statuses")
            var messageHash interface{} = "orders"
            if ccxt.IsTrue(!ccxt.IsEqual(symbol, nil)) {
                messageHash = ccxt.Add(messageHash, ccxt.Add("::", ccxt.GetValue(market, "symbol")))
            }
            messageHash = ccxt.Add(messageHash, ccxt.Add("::", rawChannel))
        
            orders:= (<-this.Subscribe(messageHash, rawChannel, this.Extend(requestArg, params)))
            ccxt.PanicOnError(orders)
            if ccxt.IsTrue(this.NewUpdates) {
                limit = ccxt.ToGetsLimit(orders).GetLimit(symbol, limit)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit, true)
            return nil
        
            }()
            return ch
        }
func  (this *ArkhamCore) HandleOrder(client interface{}, message interface{})  {
    //
    //     {
    //         channel: "order_statuses",
    //         type: "update",
    //         data: {
    //             orderId: 4200775347657,
    //             userId: 2959880,
    //             subaccountId: 0,
    //             symbol: "ARKM_USDT_PERP",
    //             time: "1755253639782186",
    //             side: "buy",
    //             type: "limitGtc",
    //             size: "10",
    //             price: "0.5",
    //             postOnly: false,
    //             reduceOnly: false,
    //             executedSize: "0",
    //             status: "cancelled",
    //             avgPrice: "0",
    //             executedNotional: "0",
    //             creditFeePaid: "0",
    //             marginBonusFeePaid: "0",
    //             quoteFeePaid: "0",
    //             arkmFeePaid: "0",
    //             revisionId: 2752963990,
    //             lastTime: "1755272026403545",
    //             clientOrderId: "",
    //             lastSize: "0",
    //             lastPrice: "0",
    //             lastCreditFee: "0",
    //             lastMarginBonusFee: "0",
    //             lastQuoteFee: "0",
    //             lastArkmFee: "0",
    //         }
    //     }
    //
    var channel interface{} = this.SafeString(message, "channel")
    var data interface{} = this.SafeDict(message, "data")
    if ccxt.IsTrue(ccxt.IsEqual(this.Orders, nil)) {
        var limit interface{} = this.SafeInteger(this.Options, "ordersLimit", 1000)
        this.Orders = ccxt.NewArrayCacheBySymbolById(limit)
    }
    var orders interface{} = this.Orders
    var order interface{} = this.ParseWsOrder(data)
    orders.(ccxt.Appender).Append(order)
    client.(ccxt.ClientInterface).Resolve(orders, "orders")
    client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add(ccxt.Add(ccxt.Add("orders::", ccxt.GetValue(order, "symbol")), "::"), channel))
    client.(ccxt.ClientInterface).Resolve(orders, ccxt.Add("orders::", channel))
}
func  (this *ArkhamCore) ParseWsOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    // same as REST api
    market := ccxt.GetArg(optionalArgs, 0, nil)
    _ = market
    return this.ParseOrder(order, market)
}
func  (this *ArkhamCore) HandleErrorMessage(client interface{}, response interface{}) interface{}  {
    //
    // error example:
    //
    //    {
    //        "id": "30005",
    //        "name": "InvalidNotional",
    //        "message": "order validation failed: invalid notional: notional 0.25 is less than min notional 1"
    //    }
    //
    var message interface{} = this.SafeString(response, "message")
    if ccxt.IsTrue(!ccxt.IsEqual(message, nil)) {
        var body interface{} = this.Json(response)
        var errorCode interface{} = this.SafeString(response, "id")
        var feedback interface{} = ccxt.Add(ccxt.Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowExactlyMatchedException(ccxt.GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(ccxt.GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ccxt.ExchangeError(ccxt.Add(ccxt.Add(this.Id, " "), body)))
    }
    return false
}


func (this *ArkhamCore) Init(userConfig map[string]interface{}) {
    this.base.Init(this.DeepExtend(this.Describe(), userConfig))
    this.Itf = this
    this.Exchange.DerivedExchange = this
}
